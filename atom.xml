<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Splinter Suidman</title>
    <link href="https://splintah.github.io/atom.xml" rel="self" />
    <link href="https://splintah.github.io" />
    <id>https://splintah.github.io/atom.xml</id>
    <author>
        <name>Splinter Suidman</name>
        <email></email>
    </author>
    <updated>2020-06-14T00:00:00Z</updated>
    <entry>
    <title>Type inference</title>
    <link href="https://splintah.github.io/posts/2020-06-14-Type-inference.html" />
    <id>https://splintah.github.io/posts/2020-06-14-Type-inference.html</id>
    <published>2020-06-14T00:00:00Z</published>
    <updated>2020-06-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <h1>Type inference</h1>
  <section class="header">
    14 June 2020
    
  </section>
  
    <section class="series-info">
      This post is part 4 of 4 of the series <a href="/series/Introduction%20to%20Type%20Systems.html">Introduction to Type Systems</a>.
    </section>
  
  <section>
    <p>In the previous post, we have added polymorphism to the simply typed lambda calculus and implemented a type checker for the polymorphic lambda calculus. In this post, we’ll explore <em>type inference</em> or <em>reconstruction</em>.</p>
<details>
<p><summary>Imports etc.</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> <span class="dt">Inference</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span>           <span class="dt">Control.Monad</span>        (when)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Except</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span>           <span class="dt">Control.Monad.RWS</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span>           <span class="dt">Data.Bifunctor</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>      <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>      (<span class="dt">Map</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>             <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">import</span>           <span class="dt">Data.Set</span>             (<span class="dt">Set</span>)</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">import</span>           <span class="dt">Test.QuickCheck</span></span></code></pre></div>
</details>
<h2 id="motivation">Motivation</h2>
<p>In the polymorphic lambda calculus, we can write polymorphic (generic) functions that work on all types, using <em>parametric polymorphism</em>. This is a major benefit over the simply typed lambda calculus, because it reduces duplication: for example, we no longer have to write an identity function for every type that we might need one for, but can write exactly one identity function that works on all types.</p>
<p>But, as you might have noticed, it is quite some work to use such polymorphic functions. Where we could define <span class="math inline">\(\mathsf{const}\)</span> as <span class="math inline">\(\lambda x. \lambda y. x\)</span> and use it like <span class="math inline">\(\mathsf{const}\ (\lambda x. x)\ (\lambda f. \lambda x. f\ x)\)</span> in the untyped lambda calculus, in the polymorphic lambda calculus we have to type <span class="math inline">\(\mathsf{const} = \Lambda X. \Lambda Y. \lambda x : X. \lambda y : Y. x\)</span> and use it like the following for the same example: <span class="math display">\[
\begin{align*}
  \mathsf{const}\ &amp; (\forall X. X \rightarrow X) \\
    &amp; (\forall A. \forall B. (A \rightarrow B) \rightarrow A \rightarrow B) \\
    &amp; (\Lambda X. \lambda x : X. x) \\
    &amp; (\Lambda A. \Lambda B. \lambda f : A \rightarrow B. \lambda x : A. f\ x)
\end{align*}
\]</span></p>
<p>We have to do a whole lot of typing to make the type checker happy. Wouldn’t it be nice if we could write our terms like in the untyped lambda calculus, with the same static safety as in the polymorphic lambda calculus? It turns out that we can actually implement a type checker that <em>infers</em> or <em>reconstructs</em> the types from a fully untyped program. This technique is called <em>type inference</em> or <em>type reconstruction</em>, and the corresponding type system is called the <em>Hindley-Milner type system</em>.</p>
<h2 id="syntax">Syntax</h2>
<p>To write programs without any type information, we remove all types from the syntax of terms. So no more type abstractions, type applications or lambda abstractions with explicit types (e.g., we’ll write <span class="math inline">\(\lambda x. x\)</span> instead of <span class="math inline">\(\lambda x : X. x\)</span>).</p>
<p>The AST looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">Term</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="ot">=</span> <span class="dt">TmTrue</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="co">-- ^ True value</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="op">|</span> <span class="dt">TmFalse</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">-- ^ False value</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="op">|</span> <span class="dt">TmInt</span> <span class="dt">Integer</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="co">-- ^ Integer value</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="op">|</span> <span class="dt">TmVar</span> <span class="dt">String</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="co">-- ^ Variable</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="op">|</span> <span class="dt">TmAbs</span> <span class="dt">String</span> <span class="dt">Term</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="co">-- ^ Lambda abstraction</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="op">|</span> <span class="dt">TmApp</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span class="co">-- ^ Application</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span class="op">|</span> <span class="dt">TmAdd</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>    <span class="co">-- ^ Addition</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="op">|</span> <span class="dt">TmIf</span> <span class="dt">Term</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="co">-- ^ If-then-else conditional</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>  <span class="op">|</span> <span class="dt">TmLet</span> <span class="dt">String</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="co">-- ^ Let-in</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>You might notice that this is just the syntax of the untyped lambda calculus (<code>TmVar</code>, <code>TmAbs</code>, <code>TmApp</code>) with the syntax constructs of the simply typed lambda calculus (<code>TmTrue</code>, <code>TmFalse</code>, <code>TmInt</code>, <code>TmAdd</code>, <code>TmIf</code>), plus the addition of the <code>TmLet</code> constructor, which is used for terms of the form <span class="math inline">\(\mathbf{let}\ x = t\ \mathbf{in}\ t&#39;\)</span>. The addition of let-in terms is not strictly necessary, but it is if we actually want to use polymorphism. (This will be discussed later.)</p>
<p>For the syntax of types, we do have to make a substantial change, though. We must restrict our usage of polymorphism: we can only use <span class="math inline">\(\forall\)</span>’s at the top level; no more <span class="math inline">\((\forall A. A \rightarrow A) \rightarrow (\forall B. B \rightarrow B)\)</span>, for example. We have to do this, because type inference for the polymorphic lambda calculus as we saw it in the previous post is <a href="https://en.wikipedia.org/wiki/Undecidable_problem">undecidable</a>. We will therefore split our type syntax into two: <em>monotypes</em> and <em>polytypes</em> (or <em>type schemes</em>).</p>
<p>The syntax for <em>polytypes</em> (for which we’ll write <span class="math inline">\(\sigma\)</span>) is very simple:</p>
<p><span class="math display">\[
\begin{align*}
  \sigma ::=\ &amp; \forall \vec{X}. \tau &amp; \text{(polytype)} \\
\end{align*}
\]</span></p>
<p>Here <span class="math inline">\(\tau\)</span> is a monotype, and <span class="math inline">\(\vec{X}\)</span> is a (possibly empty) list of type variables.</p>
<p>In Haskell, this is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Polytype</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="ot">=</span> <span class="dt">TyForall</span> [<span class="dt">String</span>] <span class="dt">Type</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>(We’ll use just <code>Type</code> to refer to monotypes.)</p>
<p>The syntax for monotypes looks like this:</p>
<p><span class="math display">\[
\begin{align*}
  \tau ::=\ &amp; X &amp; \text{(type variable)} \\
      \mid\ &amp; \tau \rightarrow \tau&#39; &amp; \text{(function type)} \\
      \mid\ &amp; \mathsf{Bool} &amp; \text{(boolean type)} \\
      \mid\ &amp; \mathsf{Int} &amp; \text{(integer type)}
\end{align*}
\]</span></p>
<p>Or in Haskell:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">data</span> <span class="dt">Type</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="ot">=</span> <span class="dt">TyVar</span> <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">-- ^ Type variable</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="op">|</span> <span class="dt">TyFun</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="co">-- ^ Function type</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="op">|</span> <span class="dt">TyBool</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="co">-- ^ Boolean type</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>  <span class="op">|</span> <span class="dt">TyInt</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="co">-- ^ Integer type</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>The type for the identity function (which we now write as just <span class="math inline">\(\lambda x. x\)</span>), <span class="math inline">\(\forall X. X \rightarrow X\)</span>, is written in Haskell as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">tmId ::</span> <span class="dt">Term</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>tmId <span class="ot">=</span> <span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ot">tyId ::</span> <span class="dt">Polytype</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>tyId <span class="ot">=</span> <span class="dt">TyForall</span> [<span class="st">&quot;X&quot;</span>] <span class="op">$</span> <span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)</span></code></pre></div>
<p>And <span class="math inline">\(\mathsf{const}\)</span>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">tmConst ::</span> <span class="dt">Term</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>tmConst <span class="ot">=</span> <span class="dt">TmAbs</span> <span class="st">&quot;a&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;b&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;a&quot;</span>))</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">tyConst ::</span> <span class="dt">Polytype</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>tyConst <span class="ot">=</span> <span class="dt">TyForall</span> [<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>] <span class="op">$</span> <span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>))</span></code></pre></div>
<h2 id="type-checking">Type checking</h2>
<p>Type inference is quite a bit harder than type checking the simply typed lambda calculus or the polymorphic lambda calculus <em>with</em> explicit type annotations. We will use a constraint-based type inference algorithm, based on <a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>, Benjamin C. Pierce, Chapter 22.3. I have found this to be the most intuitive approach. I will deviate a bit from Pierce’s approach, though, to make the rules somewhat easier to read.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>For type inference, we will use a different typing relation than the one we used for the simply typed and the polymorphic (but explicitly typed) lambda calculus. Before, we used the relation <span class="math inline">\(\Gamma \vdash t : \tau\)</span>, which could be read something like: <em><span class="math inline">\(\Gamma\)</span> entails that <span class="math inline">\(t\)</span> has type <span class="math inline">\(\tau\)</span></em>. Now, we will use the typing relation written as follows: <span class="math inline">\(\Gamma \vdash t : \tau \mid C\)</span>. This can be read as: <em><span class="math inline">\(\Gamma\)</span> entails that <span class="math inline">\(t\)</span> has type <span class="math inline">\(\tau\)</span> if the constraints of <span class="math inline">\(C\)</span> are satisfied</em>. Our type inference program will generate a set of <em>constraints</em>, which ought to be <em>satisfied</em> for the type checker to succeed. (Another change is the context <span class="math inline">\(\Gamma\)</span>, which will now contain pairs <span class="math inline">\(x : \sigma\)</span> of variables and <em>polytypes</em> instead of pairs <span class="math inline">\(x : \tau\)</span> of variables and monotypes.)</p>
<h3 id="constraint-solving">Constraint solving</h3>
<p>A <em>constraint</em> <span class="math inline">\(\tau \sim \tau&#39;\)</span> states that <span class="math inline">\(\tau\)</span> and <span class="math inline">\(\tau&#39;\)</span> should be <em>unified</em>. The constraint <span class="math inline">\(A \sim B \rightarrow \mathsf{Int}\)</span>, for example, asserts that the type variable <span class="math inline">\(A\)</span> should be equal to the type <span class="math inline">\(B \rightarrow \mathsf{Int}\)</span>. A <em>constraint set</em> <span class="math inline">\(C\)</span> is a set (or a list) of constraints. We want to write a a function that <em>unifies</em> a constraint set. This unification function will generate a substitution <span class="math inline">\(\mathcal{S}\)</span>, such that the substitution <em>unifies</em> all constraints in <span class="math inline">\(C\)</span>: for all constraints <span class="math inline">\(\tau \sim \tau&#39;\)</span>, <span class="math inline">\(\mathcal{S} \tau\)</span> (the substitution <span class="math inline">\(\mathcal{S}\)</span> applied tot type <span class="math inline">\(\tau\)</span>) should be equal to <span class="math inline">\(\mathcal{S} \tau&#39;\)</span>.</p>
<p>In Haskell, we will create the following <code>Constraint</code> type, with the infix constructor <code>(:~:)</code> that corresponds to the <span class="math inline">\(\sim\)</span> in a constraint:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">data</span> <span class="dt">Constraint</span> <span class="ot">=</span> <span class="dt">Type</span> <span class="op">:~:</span> <span class="dt">Type</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>For substitutions, we use a map:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="dt">Subst</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Type</span></span></code></pre></div>
<p>The <code>substType</code> function will apply a substitution to a type. Applying substitutions to monotypes (i.e., without <span class="math inline">\(\forall\)</span>s) is quite easy, because we don’t have to worry about renaming.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">substType ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>substType s <span class="dt">TyBool</span> <span class="ot">=</span> <span class="dt">TyBool</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>substType s <span class="dt">TyInt</span>  <span class="ot">=</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>When we come across a type variable, we replace it by the corresponding type in the substitution, or keep it when the variable does not occur in the substitution:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>substType s (<span class="dt">TyVar</span> x) <span class="ot">=</span> Map.findWithDefault (<span class="dt">TyVar</span> x) x s</span></code></pre></div>
<p>For function types, we just apply the substitution recursively:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a>substType s (<span class="dt">TyFun</span> t1 t2) <span class="ot">=</span> <span class="dt">TyFun</span> (substType s t1) (substType s t2)</span></code></pre></div>
<p>With the <code>substType</code> function, we can very easily apply a substitution to a constraint, by applying the substitution to the left-hand side and the right-hand side:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">substConstraint ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>substConstraint s (t1 <span class="op">:~:</span> t2) <span class="ot">=</span> substType s t1 <span class="op">:~:</span> substType s t2</span></code></pre></div>
<p>We can also apply a substitution to a polytype <span class="math inline">\(\forall \vec{X}. \tau\)</span>, which applies the substitution to <span class="math inline">\(\tau\)</span>, with all elements from the substitution with a key from <span class="math inline">\(\vec{X}\)</span> removed:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">substPolytype ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Polytype</span> <span class="ot">-&gt;</span> <span class="dt">Polytype</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>substPolytype s (<span class="dt">TyForall</span> xs ty) <span class="ot">=</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="kw">let</span> s&#39; <span class="ot">=</span> <span class="fu">foldr</span> Map.delete s xs</span>
<span id="cb13-4"><a href="#cb13-4"></a>   <span class="kw">in</span> <span class="dt">TyForall</span> xs (substType s&#39; ty)</span></code></pre></div>
<p>As we’ve seen in the previous post, substitution is generally quite hard for types which bind type variables, because the programmer might use the same type variable twice in different contexts, causing them to clash in some cases. Luckily, this won’t be a problem here, since the programmer doesn’t write any type variables. Instead, all type variables that we use are generated by the inference algorithm, which makes sure they are all unique (or <em>fresh</em>). This will be explained later.</p>
<p>We also need to be able to compose two substitutions. In mathematical notation, we write <span class="math inline">\(\mathcal{S}_1 \circ \mathcal{S}_2\)</span> for the composition of <span class="math inline">\(\mathcal{S}_1\)</span> and <span class="math inline">\(\mathcal{S}_2\)</span>, where <span class="math inline">\(\mathcal{S}_2\)</span> is applied first. We want <span class="math inline">\((\mathcal{S}_1 \circ \mathcal{S}_2)\tau\)</span> for any type <span class="math inline">\(\tau\)</span> to be equal to <span class="math inline">\(\mathcal{S}_1(\mathcal{S}_2\tau)\)</span>. We first apply <span class="math inline">\(\mathcal{S}_1\)</span> to the codomain (that is, the <em>values</em>, not the keys, of the <code>Map</code>) of <span class="math inline">\(\mathcal{S}_2\)</span>, and then return the union of the result and <span class="math inline">\(\mathcal{S}_1\)</span>, where values of the first substitution are preferred:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="ot">compose ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>compose s1 s2 <span class="ot">=</span> <span class="fu">fmap</span> (substType s1) s2 <span class="ot">`Map.union`</span> s1</span></code></pre></div>
<p>Then, we can write the unification function for a single constraint:</p>
<details>
<p><summary>The definition of <code>UnifyError</code></summary></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">data</span> <span class="dt">UnifyError</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>  <span class="ot">=</span> <span class="dt">CannotUnify</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="op">|</span> <span class="dt">InfiniteType</span> <span class="dt">String</span> <span class="dt">Type</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</details>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">unify ::</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnifyError</span> <span class="dt">Subst</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>unify c <span class="ot">=</span> <span class="kw">case</span> c <span class="kw">of</span></span></code></pre></div>
<p>To unify two equal simple types, we don’t have to apply any substitution, so we’ll just return an empty substitution:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>  <span class="dt">TyBool</span> <span class="op">:~:</span> <span class="dt">TyBool</span> <span class="ot">-&gt;</span> <span class="dt">Right</span> Map.empty</span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="dt">TyInt</span>  <span class="op">:~:</span> <span class="dt">TyInt</span>  <span class="ot">-&gt;</span> <span class="dt">Right</span> Map.empty</span></code></pre></div>
<p>To unify two function types, we just need to unify both parameter types and both target types. We do this using the <code>solve</code> function, which can unify a list of constraints. We’ll define <code>solve</code> later.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>  <span class="dt">TyFun</span> t1 t2 <span class="op">:~:</span> <span class="dt">TyFun</span> t1&#39; t2&#39; <span class="ot">-&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>    solve [ t1 <span class="op">:~:</span> t1&#39;</span>
<span id="cb18-3"><a href="#cb18-3"></a>          , t2 <span class="op">:~:</span> t2&#39; ]</span></code></pre></div>
<p>To unify a type variable with another type, we use the <code>bind</code> helper function, which we’ll also define later.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a>  t1      <span class="op">:~:</span> <span class="dt">TyVar</span> x <span class="ot">-&gt;</span> bind x t1</span>
<span id="cb19-2"><a href="#cb19-2"></a>  <span class="dt">TyVar</span> x <span class="op">:~:</span> t2      <span class="ot">-&gt;</span> bind x t2</span></code></pre></div>
<p>Any other constraint is unsolvable, so we’ll just throw an error:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>  t1 <span class="op">:~:</span> t2 <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">CannotUnify</span> t1 t2</span></code></pre></div>
<p>For unifying a type variable with another type, we use the <code>bind</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">bind ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnifyError</span> <span class="dt">Subst</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>bind x t</span></code></pre></div>
<p>When <code>t</code> is the same as the type variable <code>x</code>, we don’t have to do any substituting:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a>  <span class="op">|</span> t <span class="op">==</span> <span class="dt">TyVar</span> x   <span class="ot">=</span> <span class="dt">Right</span> Map.empty</span></code></pre></div>
<p>When the type variable <code>x</code> occurs freely in <code>t</code> (and it is not <code>x</code> itself, which we have checked in the previous case), we cannot unify them, since that would require infinite types. The constraint <span class="math inline">\(X \sim X \rightarrow X\)</span>, for example, has no solution:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>  <span class="op">|</span> x <span class="ot">`occursIn`</span> t <span class="ot">=</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">InfiniteType</span> x t</span></code></pre></div>
<p>Otherwise, we can just return the substitution which substitutes <code>x</code> by <code>t</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="dt">Right</span> <span class="op">$</span> Map.fromList [(x, t)]</span></code></pre></div>
<p>The <code>occursIn</code> function is very straight-forward:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="ot">occursIn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>x <span class="ot">`occursIn`</span> t <span class="ot">=</span> <span class="kw">case</span> t <span class="kw">of</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="dt">TyBool</span>      <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="dt">TyInt</span>       <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>  <span class="dt">TyFun</span> t1 t2 <span class="ot">-&gt;</span> x <span class="ot">`occursIn`</span> t1 <span class="op">||</span> x <span class="ot">`occursIn`</span> t2</span>
<span id="cb25-6"><a href="#cb25-6"></a>  <span class="dt">TyVar</span> y     <span class="ot">-&gt;</span> x <span class="op">==</span> y</span></code></pre></div>
<p>Finally, we can solve a list of constraints:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="ot">solve ::</span> [<span class="dt">Constraint</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnifyError</span> <span class="dt">Subst</span></span></code></pre></div>
<p>Solving an empty list of constraints just corresponds to doing nothing:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a>solve [] <span class="ot">=</span> <span class="dt">Right</span> Map.empty</span></code></pre></div>
<p>To solve a non-empty list of constraints, we first unify the constraint <code>c</code>, which gives us the substitution <code>s1</code>. We apply this substitution to the rest of the constraints and solve the result, giving us the substitution <code>s2</code>, and then return the composition of <code>s2</code> and <code>s1</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a>solve (c<span class="op">:</span>cs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>  s1 <span class="ot">&lt;-</span> unify c</span>
<span id="cb28-3"><a href="#cb28-3"></a>  s2 <span class="ot">&lt;-</span> solve <span class="op">$</span> <span class="fu">fmap</span> (substConstraint s1) cs</span>
<span id="cb28-4"><a href="#cb28-4"></a>  <span class="dt">Right</span> (s2 <span class="ot">`compose`</span> s1)</span></code></pre></div>
<p>Some examples:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a>solve [<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span> <span class="op">:~:</span> <span class="dt">TyInt</span>]</span>
<span id="cb29-2"><a href="#cb29-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (fromList [(<span class="st">&quot;X&quot;</span>,<span class="dt">TyInt</span>)])</span>
<span id="cb29-3"><a href="#cb29-3"></a></span>
<span id="cb29-4"><a href="#cb29-4"></a>solve [<span class="dt">TyInt</span> <span class="op">:~:</span> <span class="dt">TyBool</span>]</span>
<span id="cb29-5"><a href="#cb29-5"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">CannotUnify</span> <span class="dt">TyInt</span> <span class="dt">TyBool</span>)</span>
<span id="cb29-6"><a href="#cb29-6"></a></span>
<span id="cb29-7"><a href="#cb29-7"></a>solve [<span class="dt">TyInt</span> <span class="op">:~:</span> <span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>, <span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span> <span class="op">:~:</span> <span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyBool</span>]</span>
<span id="cb29-8"><a href="#cb29-8"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">CannotUnify</span> <span class="dt">TyInt</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyBool</span>))</span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a>solve [<span class="dt">TyInt</span> <span class="op">:~:</span> <span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>, <span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span> <span class="op">:~:</span> <span class="dt">TyBool</span>]</span>
<span id="cb29-11"><a href="#cb29-11"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (fromList [(<span class="st">&quot;X&quot;</span>,<span class="dt">TyInt</span>),(<span class="st">&quot;Y&quot;</span>,<span class="dt">TyBool</span>)])</span>
<span id="cb29-12"><a href="#cb29-12"></a></span>
<span id="cb29-13"><a href="#cb29-13"></a>solve [<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span> <span class="op">:~:</span> <span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)]</span>
<span id="cb29-14"><a href="#cb29-14"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">InfiniteType</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)))</span></code></pre></div>
<p>We can also test whether <code>solve</code> has the desired behaviour, namely that the resulting substitution unifies the constraints. To do this, we’ll use the <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library:</p>
<details>
<p><summary>Testing <code>solve</code></summary></p>
<p>We will first need an instance of <a href="https://hackage.haskell.org/package/QuickCheck/docs/Test-QuickCheck.html#t:Arbitrary"><code>Arbitrary</code></a> for <code>Type</code> and <code>Constraint</code>. The instance for <code>Type</code> is adapted from the <a href="https://github.com/nick8325/quickcheck/blob/master/examples/Lambda.hs">lambda calculus example</a>. The frequency for <code>TyInt</code> and <code>TyBool</code> are relatively low, because a frequent occurrence of these simple types in the generated arbitrary types results in a lot of failed calls to <code>solve</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>  arbitrary <span class="ot">=</span> sized arbType</span>
<span id="cb30-3"><a href="#cb30-3"></a>   <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>    arbType n <span class="ot">=</span> frequency <span class="op">$</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>      [ (<span class="dv">10</span>, <span class="dt">TyVar</span> <span class="op">&lt;$&gt;</span> arbVar)</span>
<span id="cb30-6"><a href="#cb30-6"></a>      , (<span class="dv">1</span>, <span class="fu">pure</span> <span class="dt">TyInt</span>)</span>
<span id="cb30-7"><a href="#cb30-7"></a>      , (<span class="dv">1</span>, <span class="fu">pure</span> <span class="dt">TyBool</span>)</span>
<span id="cb30-8"><a href="#cb30-8"></a>      ] <span class="op">&lt;&gt;</span></span>
<span id="cb30-9"><a href="#cb30-9"></a>      [ (<span class="dv">5</span>, <span class="dt">TyFun</span> <span class="op">&lt;$&gt;</span> arbType (n <span class="ot">`div`</span> <span class="dv">2</span>) <span class="op">&lt;*&gt;</span> arbType (n <span class="ot">`div`</span> <span class="dv">2</span>))</span>
<span id="cb30-10"><a href="#cb30-10"></a>      <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb30-11"><a href="#cb30-11"></a>      ]</span>
<span id="cb30-12"><a href="#cb30-12"></a>    arbVar <span class="ot">=</span> elements [[c] <span class="op">|</span> c <span class="ot">&lt;-</span> [<span class="ch">&#39;A&#39;</span><span class="op">..</span><span class="ch">&#39;Z&#39;</span>]]</span>
<span id="cb30-13"><a href="#cb30-13"></a></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Constraint</span> <span class="kw">where</span></span>
<span id="cb30-15"><a href="#cb30-15"></a>  arbitrary <span class="ot">=</span> (<span class="op">:~:</span>) <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</span></code></pre></div>
<p>Then we write the function <code>unifies</code>, which checks whether a substitution unifies the constraints. (Remember: a substitution <span class="math inline">\(\mathcal{S}\)</span> satisfies a list of constraints <span class="math inline">\(C\)</span> if for all constraints <span class="math inline">\(\tau \sim \tau&#39;\)</span> in <span class="math inline">\(C\)</span>, <span class="math inline">\(\mathcal{S}\tau = \mathcal{S}\tau&#39;\)</span>.)</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="ot">unifies ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> [<span class="dt">Constraint</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>unifies s cs <span class="ot">=</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>  <span class="kw">let</span> cs&#39; <span class="ot">=</span> <span class="fu">fmap</span> (substConstraint s) cs</span>
<span id="cb31-4"><a href="#cb31-4"></a>   <span class="kw">in</span> <span class="fu">all</span> (\(t1 <span class="op">:~:</span> t2) <span class="ot">-&gt;</span> t1 <span class="op">==</span> t2) cs&#39;</span></code></pre></div>
<p>Now we can write our property, which will check whether every successful <code>solve</code> returns a substitution that unifies the list of constraints. We will discard errors of <code>solve</code>, since they occur quite often for arbitrary constraints, but aren’t useful for checking the property.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">prop_solveUnifies ::</span> [<span class="dt">Constraint</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>prop_solveUnifies cs <span class="ot">=</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>  <span class="kw">case</span> solve cs <span class="kw">of</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    <span class="co">-- Discard errors</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>    <span class="dt">Left</span> _      <span class="ot">-&gt;</span> property <span class="dt">Discard</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>    <span class="dt">Right</span> subst <span class="ot">-&gt;</span> property <span class="op">$</span> unifies subst cs</span></code></pre></div>
<p>Now we can check the property:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a>ghci<span class="op">&gt;</span> quickCheck prop_solveUnifies</span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests; <span class="dv">637</span> discarded<span class="op">.</span></span></code></pre></div>
Looks good!
</details>
<h3 id="typing-rules">Typing rules</h3>
<p>Now we know how to solve constraints, but we don’t know how to actually generate them. The typing rules will generate the constraints that should be solves afterwards.</p>
<p>Let’s first look at some easy rules. The rules for the values of the simple types are the still the same as for the simply typed lambda calculus, with the addition of <span class="math inline">\(\ldots \mid \varnothing\)</span> at the end of the judgement, which states that the rules don’t generate any constraints (an empty set):</p>
<p>The rule for applications is also not that hard:</p>
<p><span class="math display">\[
  \text{T-App: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      X \text{ fresh} \\
      C&#39; = C_1 \cup C_2 \cup \{\tau_1 \sim \tau_2 \rightarrow X\}
    \end{array}
  }{
    \Gamma \vdash t_1\ t_2 : X \mid C&#39;
  }
\]</span></p>
<p>When type checking the application <span class="math inline">\(t_1\ t_2\)</span>, we first type check <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span>. We then generate a new constraint set which consists of all the constraints of <span class="math inline">\(C_1\)</span>, all of <span class="math inline">\(C_2\)</span> and the constraint <span class="math inline">\(\tau_1 \sim \tau_2 \rightarrow X\)</span>. (The <span class="math inline">\(\cup\)</span> symbol is mathematical notation for the <a href="https://en.wikipedia.org/wiki/Union_%28set_theory%29"><em>union</em></a> of two sets.) Because <span class="math inline">\(t_1\)</span> is applied to <span class="math inline">\(t_2\)</span>, <span class="math inline">\(t_1\)</span> should be a function with a parameter of the type of <span class="math inline">\(t_2\)</span>. We can’t yet know the resulting type, so we use a fresh type variable, denoted by <span class="math inline">\(X\)</span>, for which we add the constraint that <span class="math inline">\(\tau_1\)</span> should be equal to <span class="math inline">\(\tau_2 \rightarrow X\)</span>.</p>
<p>To state that <span class="math inline">\(X\)</span> should be a freshly chosen type variable, we write <span class="math inline">\(X \text{ fresh}\)</span> in the typing rule. A fresh type variable is a type variable which is not already used elsewhere. Because all terms are implicitly typed (that is, they don’t contain types in their syntax), we can confidently use a predefined list of fresh type variables, since there is no chance of them clashing with type variables written by the programmer (because they don’t exist).</p>
<p>Other rules might add constraints regarding <span class="math inline">\(X\)</span>. The type inference of <span class="math inline">\(t_1\ t_2 + 3\)</span>, for example, will add the constraint <span class="math inline">\(X \sim \mathsf{Int}\)</span>.</p>
<p>The typing rules for if-then-else terms and addition terms are very easy: they are almost the same as for the simply typed lambda calculus, but now we can use constraints to specify that the condition of an if-then-else term must be a boolean, etc.:</p>
<p><span class="math display">\[
  \text{T-If: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      \Gamma \vdash t_3 : \tau_3 \mid C_3 \\
      C&#39; = C_1 \cup C_2 \cup C_3 \cup \{\tau_1 \sim \mathsf{Bool}, \tau_2 \sim \tau_3\}
    \end{array}
  }{
    \Gamma \vdash \mathbf{if}\ t_1\ \mathbf{then}\ t_2\ \mathbf{else}\ t_3 : \tau_2 \mid C&#39;
  }
\]</span></p>
<p><span class="math display">\[
  \text{T-Add: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      C&#39; = C_1 \cup C_2 \cup \{\tau_1 \sim \mathsf{Int}, \tau_2 \sim \mathsf{Int}\}
    \end{array}
  }{
    \Gamma \vdash t_1 + t_2 : \mathsf{Int} \mid C&#39;
  }
\]</span></p>
<p>The rule for variables is a bit more involved. It looks like this:</p>
<p><span class="math display">\[
  \text{T-Var: } \frac{
    \begin{array}{c}
      x : \sigma \in \Gamma \\
      \tau = \mathit{inst}(\sigma)
    \end{array}
  }{
    \Gamma \vdash x : \tau \mid \varnothing
  }
\]</span></p>
<p>Remember that the context <span class="math inline">\(\Gamma\)</span> contains polytypes, but our typing relation uses monotypes (<span class="math inline">\(\Gamma \vdash t : \tau\)</span> instead of <span class="math inline">\(\Gamma \vdash t : \sigma\)</span>). To fix this, we use a function called <span class="math inline">\(\mathit{inst}\)</span> (short for ‘instantiate’), which takes as its parameter a polytype <span class="math inline">\(\forall \vec{X}. \tau\)</span>. For every type variable <span class="math inline">\(X_i\)</span> in <span class="math inline">\(\vec{X}\)</span> (which is a list of type variables), it generates a new, fresh type variable <span class="math inline">\(Y_i\)</span>. It then performs the substitution <span class="math inline">\([X_1 := Y_1, \ldots, X_n := Y_n]\)</span> on <span class="math inline">\(\tau\)</span> and returns the result.</p>
<p>This trick is necessary for <em>let-polymorphism</em> (which I’ll discuss in more detail for the typing rule for let-in terms). When inferring the type of the term <span class="math display">\[
\begin{array}{l}
  \mathbf{let}\ \mathsf{id} = \lambda x. x\ \mathbf{in} \\
  \mathbf{if}\ \mathsf{id}\ \mathsf{True}\ \mathbf{then}\ \mathsf{id}\ 4\ \mathbf{else}\ 5
\end{array}
\]</span> we would add <span class="math inline">\(\mathsf{id} : \forall A. A \rightarrow A\)</span> to the context. When we come across the term <span class="math inline">\(\mathsf{id}\ \mathsf{True}\)</span>, we would (without using <span class="math inline">\(\mathit{inst}\)</span>) add the constraint <span class="math inline">\(A \sim \mathsf{Bool}\)</span>. But later, when we type check <span class="math inline">\(\mathsf{if}\ 4\)</span>, we would also add the constraint <span class="math inline">\(A \sim \mathsf{Int}\)</span>. This results in an error, since the unification algorithm can’t unify <span class="math inline">\(\mathsf{Bool} \sim \mathsf{Int}\)</span> (and rightly so). <span class="math inline">\(\mathit{inst}\)</span> prevents this problem, as we’ll see when looking at T-Let.</p>
<p>The rule for lambda abstractions looks like this:</p>
<p><span class="math display">\[
  \text{T-Abs: } \frac{
    \begin{array}{c}
      X \text{ fresh} \\
      \Gamma, x : \forall \varnothing. X \vdash t : \tau \mid C
    \end{array}
  }{
    \Gamma \vdash \lambda x. t : X \rightarrow \tau \mid C
  }
\]</span></p>
<p>This can be read as follows: <em>if <span class="math inline">\(X\)</span> is a free type variable and <span class="math inline">\(\Gamma, x : \forall \varnothing. X\)</span> entails that <span class="math inline">\(t\)</span> has type <span class="math inline">\(\tau\)</span> with the generated constraints <span class="math inline">\(C\)</span>, then <span class="math inline">\(\Gamma\)</span> entails that <span class="math inline">\(\lambda x. t\)</span> has type <span class="math inline">\(X \rightarrow \tau\)</span> with the same generated constraint set <span class="math inline">\(C\)</span>.</em> Since the constraint set stays the same, the T-Abs rule does not introduce any constraints.</p>
<p>Because lambda abstractions are no longer annotated with the type of the parameter (<span class="math inline">\(\lambda x : \tau. t\)</span>), we don’t know what type we should give <span class="math inline">\(x\)</span> in the context to type check the body of the lambda abstraction (<span class="math inline">\(t\)</span>). We therefore use a fresh type variable <span class="math inline">\(X\)</span> as <span class="math inline">\(x\)</span>’s type. But, since the context contains polytypes, we can’t just add the pair <span class="math inline">\(x : X\)</span>. We instead add the pair <span class="math inline">\(x : \forall \varnothing. X\)</span>.</p>
<p>Not binding <span class="math inline">\(X\)</span> with a <span class="math inline">\(\forall\)</span> (i.e., adding <span class="math inline">\(x : \forall X. X\)</span>) prevents <span class="math inline">\(\mathit{inst}\)</span> from applying let-polymorphism to the arguments of lambda abstractions. The above example using a let-in term would not work as a lambda abstraction: <span class="math inline">\((\lambda \mathsf{id}. \mathbf{if}\ \mathsf{id}\ \mathsf{True}\ \mathbf{then}\ \mathsf{id}\ 4\ \mathbf{else}\ 5)\ (\lambda x. x)\)</span> would fail to type check.</p>
<p>The rule for let-in terms, finally, looks like this:</p>
<p><span class="math display">\[
  \text{T-Let: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \mathcal{S} = \mathit{solve}(C_1) \\
      \sigma = \mathit{gen}(\mathcal{S}\Gamma, \mathcal{S}\tau_1) \\
      \Gamma, x : \sigma \vdash t_2 : \tau_2 \mid C_2
    \end{array}
  }{
    \Gamma \vdash \mathbf{let}\ x = t_1\ \mathbf{in}\ t_2 : \tau_2 \mid C_2
  }
\]</span></p>
<p>This rule is executed in the following steps:</p>
<ol type="1">
<li>The type of <span class="math inline">\(t_1\)</span> is determined.</li>
<li>The constraints generated while inferring the type of <span class="math inline">\(t_1\)</span> are solved using the <code>solve</code> function, giving us the substitution <span class="math inline">\(\mathcal{S}\)</span>.</li>
<li>The substitution is applied to the context <span class="math inline">\(\Gamma\)</span> and <span class="math inline">\(\tau_1\)</span> and the resulting type is <em>generalised</em> (using the <span class="math inline">\(\mathit{gen}\)</span> function). The <span class="math inline">\(\mathit{gen}\)</span> function creates a polytype <span class="math inline">\(\sigma\)</span> of the form <span class="math inline">\(\forall \vec{X}. \mathcal{S}\tau_1\)</span> for the monotype <span class="math inline">\(\mathcal{S}\tau_1\)</span> in which all free type variables <span class="math inline">\(\vec{X}\)</span> of <span class="math inline">\(\mathcal{S}\tau_1\)</span> (not occurring in <span class="math inline">\(\mathcal{S}\Gamma\)</span>) are bound by a <span class="math inline">\(\forall\)</span>.</li>
<li>The type of <span class="math inline">\(t_2\)</span> is determined with <span class="math inline">\(x : \sigma\)</span> added to the context.</li>
</ol>
<p>This rule adds <em>let-polymorphism</em> to the language. These quite complicated steps are necessary to actually make use of polymorphism. As we saw before, we want lambda abstractions to not support polymorphism, so a parameter can only be used on one concrete type. But for let-in terms, we do want to be able to use the bound variable on multiple concrete types: the identity function on booleans, integers, integer-to-boolean functions, etc.</p>
<p>In the rule for variables, T-Var, we introduced the <span class="math inline">\(\mathit{inst}\)</span> function. It creates a fresh type variable for every type variable bound in a polytype. To prevent it from generalising the parameters of lambda abstractions, we didn’t bind any type variables in the polytype we added to the context: <span class="math inline">\(\forall \varnothing. X\)</span>. For let-in terms, however, we do want <span class="math inline">\(\mathit{inst}\)</span> to create another instance for the bound variable for every occurrence. Therefore, we find the most general type for the variable, and add it to the context. When type checking the term <span class="math inline">\(\mathbf{let}\ \mathsf{id} = \lambda x. x\ \mathbf{in}\ \mathsf{id}\ 1\)</span>, for example, <span class="math inline">\(\mathsf{id}\)</span> is added to the context with its most general type: <span class="math inline">\(\forall X. X \rightarrow X\)</span>. When typing the body of the let-in term, then, the type of <span class="math inline">\(\mathsf{id}\)</span> is instantiated as <span class="math inline">\(Y \rightarrow Y\)</span> for example. Then the constraint <span class="math inline">\(Y \sim \mathsf{Int}\)</span> is generated, because <span class="math inline">\(\mathsf{id}\)</span> is applied to <span class="math inline">\(1\)</span>, but <span class="math inline">\(X\)</span> is still untouched.</p>
<p>With these typing rules, we can move on to implementing the type inference algorithm.</p>
<h3 id="implementation">Implementation</h3>
<p>For the implementation, we will use so-called <a href="https://hackage.haskell.org/package/mtl">monad transformers</a>. However, you should not need to understand how monad transformers work in order to understand the implementation.</p>
<p>Our inference monad looks like this:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">type</span> <span class="dt">Infer</span> a <span class="ot">=</span> <span class="dt">RWST</span> <span class="dt">Context</span> [<span class="dt">Constraint</span>] [<span class="dt">String</span>] (<span class="dt">Except</span> <span class="dt">TypeError</span>) a</span>
<span id="cb34-2"><a href="#cb34-2"></a></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="kw">type</span> <span class="dt">Context</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Polytype</span></span></code></pre></div>
<details>
<p><summary>The definition of <code>TypeError</code></summary></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">data</span> <span class="dt">TypeError</span></span></code></pre></div>
<p>The variable was not bound by a lambda abstraction.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a>  <span class="ot">=</span> <span class="dt">UnboundVariable</span> <span class="dt">String</span></span></code></pre></div>
<p>An error occurred during unification.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a>  <span class="op">|</span> <span class="dt">UnifyError</span> <span class="dt">UnifyError</span></span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</details>
<p>The inference monad is a <code>Reader</code> monad for the <code>Context</code>, which is practically the same as having a <code>Context</code> parameter for every function inside the <code>Infer</code> monad, which is what we did before. Everywhere inside the <code>Infer</code> monad we can get the context, but we can’t change it. <code>Infer</code> is also a <code>Writer</code> for a list of <code>Constraint</code>s, which means that we can write to a list of constraints. This list of constraints is the <span class="math inline">\(\ldots \mid C\)</span> in the typing rules. <code>Infer</code> is furthermore a <code>State</code> for a list of <code>String</code>s, which will be the supply of fresh type variables. And lastly, <code>Infer</code> can throw <code>TypeError</code>s.</p>
<p>Using <code>runInfer</code>, we can convert a value of <code>Infer a</code> to an <code>Either TypeError (a, [String], [Constraint])</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="ot">runInfer ::</span> <span class="dt">Context</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>         <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb39-3"><a href="#cb39-3"></a>         <span class="ot">-&gt;</span> <span class="dt">Infer</span> a</span>
<span id="cb39-4"><a href="#cb39-4"></a>         <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeError</span> (a, [<span class="dt">String</span>], [<span class="dt">Constraint</span>])</span>
<span id="cb39-5"><a href="#cb39-5"></a>runInfer ctx fs m <span class="ot">=</span> runExcept <span class="op">$</span> runRWST m ctx fs</span></code></pre></div>
<p>First, we need a function that generates a fresh type variable. The state should be an infinite list of type variable names, so we should always be able to get the following element from the list:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="ot">fresh ::</span> <span class="dt">Infer</span> <span class="dt">String</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>fresh <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>  freshVars <span class="ot">&lt;-</span> get</span>
<span id="cb40-4"><a href="#cb40-4"></a>  <span class="kw">case</span> freshVars <span class="kw">of</span></span>
<span id="cb40-5"><a href="#cb40-5"></a>    []     <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Non-infinite list of fresh type variables.&quot;</span></span>
<span id="cb40-6"><a href="#cb40-6"></a>    (f<span class="op">:</span>fs) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>      put fs</span>
<span id="cb40-8"><a href="#cb40-8"></a>      <span class="fu">pure</span> f</span></code></pre></div>
<p>With <code>get :: Infer [String]</code> we can get the list of type variables. When it’s empty, we just use <code>error</code> since the programmer has made a mistake by not using an infinite list of fresh type variables. When the list is non-empty, we return the <code>head</code>, and we use the <code>tail</code> as the new state by using <code>put :: [String] -&gt; Infer ()</code>, which replaces the state.</p>
<p>For the initial state of fresh variables, we will use the following:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="ot">freshVariables ::</span> [<span class="dt">String</span>]</span>
<span id="cb41-2"><a href="#cb41-2"></a>freshVariables <span class="ot">=</span> <span class="fu">concatMap</span> (\n <span class="ot">-&gt;</span> [l <span class="op">:</span> n <span class="op">|</span> l <span class="ot">&lt;-</span> [<span class="ch">&#39;A&#39;</span><span class="op">..</span><span class="ch">&#39;Z&#39;</span>]]) <span class="op">$</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>  <span class="st">&quot;&quot;</span> <span class="op">:</span> <span class="fu">fmap</span> <span class="fu">show</span> [<span class="dv">1</span><span class="op">..</span>]</span></code></pre></div>
<p>This list will look something like:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a>[<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="op">...</span>, <span class="st">&quot;Z&quot;</span>, <span class="st">&quot;A1&quot;</span>, <span class="st">&quot;B1&quot;</span>, <span class="op">...</span>, <span class="st">&quot;Z1&quot;</span>, <span class="st">&quot;A2&quot;</span>, <span class="st">&quot;B2&quot;</span>, <span class="op">...</span>]</span></code></pre></div>
<p>We will also need the <code>inst</code> function:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="ot">inst ::</span> <span class="dt">Polytype</span> <span class="ot">-&gt;</span> <span class="dt">Infer</span> <span class="dt">Type</span></span>
<span id="cb43-2"><a href="#cb43-2"></a>inst (<span class="dt">TyForall</span> xs ty) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb43-3"><a href="#cb43-3"></a>  ys <span class="ot">&lt;-</span> <span class="fu">mapM</span> (<span class="fu">const</span> fresh) xs</span>
<span id="cb43-4"><a href="#cb43-4"></a>  <span class="kw">let</span> subst <span class="ot">=</span> Map.fromList <span class="op">$</span> <span class="fu">zip</span> xs (<span class="fu">fmap</span> <span class="dt">TyVar</span> ys)</span>
<span id="cb43-5"><a href="#cb43-5"></a>  <span class="fu">pure</span> <span class="op">$</span> substType subst ty</span></code></pre></div>
<p>For every type variable <span class="math inline">\(X\)</span> bound by the <span class="math inline">\(\forall\)</span>, we create a fresh type variable <span class="math inline">\(Y\)</span>. Then we apply the substitution which substitutes every <span class="math inline">\(X_i\)</span> for <span class="math inline">\(Y_i\)</span>.</p>
<p>We also need the <code>gen</code> function, but before we can write it, we need to be able to get the set of free type variables from a type:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="ot">freeVarsType ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">String</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>freeVarsType <span class="dt">TyBool</span>        <span class="ot">=</span> Set.empty</span>
<span id="cb44-3"><a href="#cb44-3"></a>freeVarsType <span class="dt">TyInt</span>         <span class="ot">=</span> Set.empty</span>
<span id="cb44-4"><a href="#cb44-4"></a>freeVarsType (<span class="dt">TyVar</span> x)     <span class="ot">=</span> Set.singleton x</span>
<span id="cb44-5"><a href="#cb44-5"></a>freeVarsType (<span class="dt">TyFun</span> t1 t2) <span class="ot">=</span> freeVarsType t1 <span class="ot">`Set.union`</span> freeVarsType t2</span></code></pre></div>
<p>And the free type variables from a polytype, which are the free type variables in the monotype that are not bound by the <span class="math inline">\(\forall\)</span>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a><span class="ot">freeVarsPolytype ::</span> <span class="dt">Polytype</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">String</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>freeVarsPolytype (<span class="dt">TyForall</span> xs ty) <span class="ot">=</span> freeVarsType ty <span class="ot">`Set.difference`</span> Set.fromList xs</span></code></pre></div>
<p>And also from the context, which corresponds to the union of the free type variables of all polytypes in the context:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a><span class="ot">freeVarsContext ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">String</span></span>
<span id="cb46-2"><a href="#cb46-2"></a>freeVarsContext <span class="ot">=</span> <span class="fu">foldMap</span> freeVarsPolytype</span></code></pre></div>
<p>Now we can write <code>gen</code>. We will write it outside the <code>Infer</code> monad, because it will be useful elsewhere too.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="ot">gen ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Polytype</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>gen ctx ty <span class="ot">=</span></span>
<span id="cb47-3"><a href="#cb47-3"></a>  <span class="kw">let</span> xs <span class="ot">=</span> Set.toList (freeVarsType ty <span class="ot">`Set.difference`</span> freeVarsContext ctx)</span>
<span id="cb47-4"><a href="#cb47-4"></a>   <span class="kw">in</span> <span class="dt">TyForall</span> xs ty</span></code></pre></div>
<p><code>gen</code> just finds the free type variables of <code>ty</code> which don’t occur in the context, and returns a polytype in which those type variables are bound.</p>
<p>We will also need to be able to apply a substitution to a context, by applying the substitution to every polytype in the context:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1"></a><span class="ot">substContext ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Context</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>substContext s <span class="ot">=</span> <span class="fu">fmap</span> (substPolytype s)</span></code></pre></div>
<p>Now we can finally implement the type inference algorithm:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1"></a><span class="ot">infer ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Infer</span> <span class="dt">Type</span></span></code></pre></div>
<p><span class="math display">\[
  \text{T-False: } \frac{
  }{
    \varnothing \vdash \mathsf{True} : \mathsf{Bool} \mid \varnothing
  }
\]</span></p>
<p><span class="math display">\[
  \text{T-True: } \frac{
  }{
    \varnothing \vdash \mathsf{True} : \mathsf{Bool} \mid \varnothing
  }
\]</span></p>
<p><span class="math display">\[
  \text{T-Int: } \frac{
  }{
    \varnothing \vdash n : \mathsf{Int} \mid \varnothing
  }
\]</span></p>
<p>Values of the simple types are, of course, easy:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a>infer <span class="dt">TmFalse</span>   <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">TyBool</span></span>
<span id="cb50-2"><a href="#cb50-2"></a>infer <span class="dt">TmTrue</span>    <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">TyBool</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>infer (<span class="dt">TmInt</span> _) <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">TyInt</span></span></code></pre></div>
<p><span class="math display">\[
  \text{T-App: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      X \text{ fresh} \\
      C&#39; = C_1 \cup C_2 \cup \{\tau_1 \sim \tau_2 \rightarrow X\}
    \end{array}
  }{
    \Gamma \vdash t_1\ t_2 : X \mid C&#39;
  }
\]</span></p>
<p>For applications:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a>infer (<span class="dt">TmApp</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We first infer the types of <code>t1</code> and <code>t2</code>:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a>  ty1 <span class="ot">&lt;-</span> infer t1</span>
<span id="cb52-2"><a href="#cb52-2"></a>  ty2 <span class="ot">&lt;-</span> infer t2</span></code></pre></div>
<p>We generate a fresh type variable <code>f</code>:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a>  f <span class="ot">&lt;-</span> <span class="dt">TyVar</span> <span class="op">&lt;$&gt;</span> fresh</span></code></pre></div>
<p>We generate the constraint <code>ty1 :~: TyFun ty2 f</code>. We can add it to the list of constraints using the <code>tell :: [Constraint] -&gt; Infer ()</code> function.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a>  tell [ty1 <span class="op">:~:</span> <span class="dt">TyFun</span> ty2 f]</span></code></pre></div>
<p>Finally, we return the fresh type variable as the type:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a>  <span class="fu">pure</span> f</span></code></pre></div>
<p><span class="math display">\[
  \text{T-If: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      \Gamma \vdash t_3 : \tau_3 \mid C_3 \\
      C&#39; = C_1 \cup C_2 \cup C_3 \cup \{\tau_1 \sim \mathsf{Bool}, \tau_2 \sim \tau_3\}
    \end{array}
  }{
    \Gamma \vdash \mathbf{if}\ t_1\ \mathbf{then}\ t_2\ \mathbf{else}\ t_3 : \tau_2 \mid C&#39;
  }
\]</span></p>
<p>For if-then-else terms, we generate the constraints that the condition should be a boolean and that the arms should be of the same type :</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a>infer (<span class="dt">TmIf</span> t1 t2 t3) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>  ty1 <span class="ot">&lt;-</span> infer t1</span>
<span id="cb56-3"><a href="#cb56-3"></a>  ty2 <span class="ot">&lt;-</span> infer t2</span>
<span id="cb56-4"><a href="#cb56-4"></a>  ty3 <span class="ot">&lt;-</span> infer t3</span>
<span id="cb56-5"><a href="#cb56-5"></a>  tell [ty1 <span class="op">:~:</span> <span class="dt">TyBool</span>, ty2 <span class="op">:~:</span> ty3]</span>
<span id="cb56-6"><a href="#cb56-6"></a>  <span class="fu">pure</span> ty2</span></code></pre></div>
<p><span class="math display">\[
  \text{T-Add: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      C&#39; = C_1 \cup C_2 \cup \{\tau_1 \sim \mathsf{Int}, \tau_2 \sim \mathsf{Int}\}
    \end{array}
  }{
    \Gamma \vdash t_1 + t_2 : \mathsf{Int} \mid C&#39;
  }
\]</span></p>
<p>The operands of an addition should be integers, and the result is also an integer:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1"></a>infer (<span class="dt">TmAdd</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>  ty1 <span class="ot">&lt;-</span> infer t1</span>
<span id="cb57-3"><a href="#cb57-3"></a>  ty2 <span class="ot">&lt;-</span> infer t2</span>
<span id="cb57-4"><a href="#cb57-4"></a>  tell [ty1 <span class="op">:~:</span> <span class="dt">TyInt</span>, ty2 <span class="op">:~:</span> <span class="dt">TyInt</span>]</span>
<span id="cb57-5"><a href="#cb57-5"></a>  <span class="fu">pure</span> <span class="dt">TyInt</span></span></code></pre></div>
<p><span class="math display">\[
  \text{T-Var: } \frac{
    \begin{array}{c}
      x : \sigma \in \Gamma \\
      \tau = \mathit{inst}(\sigma)
    \end{array}
  }{
    \Gamma \vdash x : \tau \mid \varnothing
  }
\]</span></p>
<p>For variables, we use the <code>inst</code> function:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1"></a>infer (<span class="dt">TmVar</span> x) <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We can get the context using <code>ask</code>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1"></a>  ctx <span class="ot">&lt;-</span> ask</span></code></pre></div>
<p>We look up <code>x</code>:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1"></a>  <span class="kw">case</span> Map.lookup x ctx <span class="kw">of</span></span></code></pre></div>
<p>When it doesn’t exist in the context, we use <code>throwError :: TypeError -&gt; Infer ()</code> to throw an error:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> throwError <span class="op">$</span> <span class="dt">UnboundVariable</span> x</span></code></pre></div>
<p>Otherwise, we use <code>inst</code> on the type:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1"></a>    <span class="dt">Just</span> ty <span class="ot">-&gt;</span> inst ty</span></code></pre></div>
<p><span class="math display">\[
  \text{T-Abs: } \frac{
    \begin{array}{c}
      X \text{ fresh} \\
      \Gamma, x : \forall \varnothing. X \vdash t : \tau \mid C
    \end{array}
  }{
    \Gamma \vdash \lambda x. t : X \rightarrow \tau \mid C
  }
\]</span></p>
<p>Then lambda abstractions. Using <code>local :: (Context -&gt; Context) -&gt; Infer a -&gt; Infer a</code> we can update the context for a local sub-computation. To infer the type of <code>t</code>, we need to add <code>x</code>’s type to the context, so we use <code>local</code>. Note that the context is not changed in the outer computation:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1"></a>infer (<span class="dt">TmAbs</span> x t) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>  f <span class="ot">&lt;-</span> <span class="dt">TyVar</span> <span class="op">&lt;$&gt;</span> fresh </span>
<span id="cb63-3"><a href="#cb63-3"></a>  ty <span class="ot">&lt;-</span> local (Map.insert x (<span class="dt">TyForall</span> [] f)) <span class="op">$</span> infer t</span>
<span id="cb63-4"><a href="#cb63-4"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">TyFun</span> f ty</span></code></pre></div>
<p><span class="math display">\[
  \text{T-Let: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \mathcal{S} = \mathit{solve}(C_1) \\
      \sigma = \mathit{gen}(\mathcal{S}\Gamma, \mathcal{S}\tau_1) \\
      \Gamma, x : \sigma \vdash t_2 : \tau_2 \mid C_2
    \end{array}
  }{
    \Gamma \vdash \mathbf{let}\ x = t_1\ \mathbf{in}\ t_2 : \tau_2 \mid C_2
  }
\]</span></p>
<p>And, finally, let-in terms:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1"></a>infer (<span class="dt">TmLet</span> x t1 t2) <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We first get the context:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1"></a>  ctx <span class="ot">&lt;-</span> ask</span></code></pre></div>
<p>Then we use <code>listen :: Infer a -&gt; Infer (a, [Constraint])</code> to ‘listen’ to the constraints generated by <code>infer t1</code>. These constraints will not be added to the final list of constraints, but are only generated ‘locally’:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1"></a>  (ty1, cs) <span class="ot">&lt;-</span> listen <span class="op">$</span> infer t1</span></code></pre></div>
<p>Now we try to solve the constraints. If they’re not solvable, we just throw an error. Otherwise, we obtain a substitution:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1"></a>  subst <span class="ot">&lt;-</span> <span class="kw">case</span> solve cs <span class="kw">of</span></span>
<span id="cb67-2"><a href="#cb67-2"></a>    <span class="dt">Left</span> e  <span class="ot">-&gt;</span> throwError <span class="op">$</span> <span class="dt">UnifyError</span> e</span>
<span id="cb67-3"><a href="#cb67-3"></a>    <span class="dt">Right</span> s <span class="ot">-&gt;</span> <span class="fu">pure</span> s</span></code></pre></div>
<p>We apply the substitution to <code>t1</code>’s type, <code>ty1</code>, giving us <code>ty1'</code>.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1"></a>  <span class="kw">let</span> ty1&#39; <span class="ot">=</span> substType subst ty1</span></code></pre></div>
<p>And we generalise <code>ty1'</code> in the context to which we have also applied the substitution, giving us a polytype <code>s</code>:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1"></a>  <span class="kw">let</span> s <span class="ot">=</span> gen (substContext subst ctx) ty1&#39;</span></code></pre></div>
<p>We add <code>s</code> to the context and infer <code>t2</code>’s type:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1"></a>  local (Map.insert x s) <span class="op">$</span> infer t2</span></code></pre></div>
<p>That’s it! We’ve written an function which runs the inference algorithm on a term, giving us a type and a list of constraints.</p>
<p>Now, we still need to solve the constraints and apply the substitution to the type. We will write the function <code>polytypeOf</code>, which runs the inference algorithm, solves the constraints, applies the substitution, and turns the resulting type into a polytype:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1"></a><span class="ot">polytypeOf ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeError</span> <span class="dt">Polytype</span></span>
<span id="cb71-2"><a href="#cb71-2"></a>polytypeOf t <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>Run the inference algorithm in an empty context<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, giving us a type <code>ty</code>, a list of fresh variables <code>fs</code> and a list of constraints <code>cs</code>:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1"></a>  (ty, fs, cs) <span class="ot">&lt;-</span> runInfer Map.empty freshVariables <span class="op">$</span> infer t</span></code></pre></div>
<p>Solve the constraints to obtain a substitution. Because <code>solve</code> returns an <code>Either UnifyError Subst</code>, we need to turn its error into a <code>TypeError</code>, which we can do by applying the type constructor <code>TypeError</code> to it. To do this, we use <code>first :: Bifunctor p =&gt; (a -&gt; b) -&gt; p a c -&gt; p b c</code>:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1"></a>  subst <span class="ot">&lt;-</span> first <span class="dt">UnifyError</span> <span class="op">$</span> solve cs</span></code></pre></div>
<p>We apply the substitution to <code>ty</code>:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1"></a>  <span class="kw">let</span> ty&#39; <span class="ot">=</span> substType subst ty</span></code></pre></div>
<p>We generalise the type in an empty context, giving us the polytype <code>s</code>:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1"></a>  <span class="kw">let</span> s <span class="ot">=</span> gen Map.empty ty&#39;</span></code></pre></div>
<p>And we return <code>s</code>:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1"></a>  <span class="dt">Right</span> s</span></code></pre></div>
<p>Let’s try it!</p>
<p>The type of <code>id</code>:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1"></a>polytypeOf tmId</span>
<span id="cb77-2"><a href="#cb77-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> [<span class="st">&quot;A&quot;</span>] (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)))</span></code></pre></div>
<p>That is <span class="math inline">\(\forall A. A \rightarrow A\)</span>, correct!</p>
<p>The type of <code>const</code>:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1"></a>polytypeOf tmConst</span>
<span id="cb78-2"><a href="#cb78-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> [<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>] (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>))))</span></code></pre></div>
<p><span class="math inline">\(\forall A\ B. A \rightarrow B \rightarrow A\)</span>, again correct!</p>
<p>Now let’s try to use let-polymorphism, by trying the term: <span class="math display">\[
\begin{array}{l}
  \mathbf{let}\ \mathsf{id} = \lambda x. x\ \mathbf{in} \\
  \mathbf{if}\ \mathsf{id}\ \mathsf{True}\ \mathbf{then}\ \mathsf{id}\ 4\ \mathbf{else}\ 5
\end{array}
\]</span></p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1"></a>polytypeOf (<span class="dt">TmLet</span> <span class="st">&quot;id&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">TmIf</span> (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) <span class="dt">TmTrue</span>) (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) (<span class="dt">TmInt</span> <span class="dv">4</span>)) (<span class="dt">TmInt</span> <span class="dv">5</span>)))</span>
<span id="cb79-2"><a href="#cb79-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> [] <span class="dt">TyInt</span>)</span></code></pre></div>
<p>And the same term, but using a lambda abstraction:</p>
<p><span class="math display">\[
  (\lambda \mathsf{id}. \mathbf{if}\ \mathsf{id}\ \mathsf{True}\ \mathbf{then}\ \mathsf{id}\ 4\ \mathbf{else}\ 5)\ (\lambda x. x)
\]</span></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1"></a>polytypeOf (<span class="dt">TmApp</span> (<span class="dt">TmAbs</span> <span class="st">&quot;id&quot;</span> (<span class="dt">TmIf</span> (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) <span class="dt">TmTrue</span>) (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) (<span class="dt">TmInt</span> <span class="dv">4</span>)) (<span class="dt">TmInt</span> <span class="dv">5</span>))) (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)))</span>
<span id="cb80-2"><a href="#cb80-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">UnifyError</span> (<span class="dt">CannotUnify</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>))</span></code></pre></div>
<p>Just like we expected, it can’t unify <span class="math inline">\(\mathsf{Bool} \sim \mathsf{Int}\)</span>.</p>
<p>One more: <span class="math display">\[
\begin{array}{l}
  \mathbf{let}\ \mathsf{id} = \lambda x. x\ \mathbf{in} \\
  \mathbf{let}\ \mathsf{const} = \lambda a. \lambda b. a\ \mathbf{in} \\
  \mathsf{const}\ \mathsf{id}\ \mathsf{const}
\end{array}
\]</span></p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1"></a>polytypeOf <span class="op">$</span> <span class="dt">TmLet</span> <span class="st">&quot;id&quot;</span> tmId <span class="op">$</span> <span class="dt">TmLet</span> <span class="st">&quot;const&quot;</span> tmConst <span class="op">$</span> <span class="dt">TmApp</span> (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;const&quot;</span>) (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>)) (<span class="dt">TmVar</span> <span class="st">&quot;const&quot;</span>)</span>
<span id="cb81-2"><a href="#cb81-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> [<span class="st">&quot;F&quot;</span>] (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;F&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;F&quot;</span>)))</span></code></pre></div>
<p>It returns <span class="math inline">\(\forall F. F \rightarrow F\)</span>, which is exactly the type of <span class="math inline">\(\mathsf{id}\)</span>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We’ve explored Hindley-Milner type inference, and implemented a type inference algorithm! This language is already quite close to Haskell.</p>
<p>Some exercises you might like to do:</p>
<ol type="1">
<li>Write a function <code>simplPolytype</code> which ‘simplifies’ a polytype. It should rename the bound variables in a polytype to names in the beginning of the alphabet (or: the beginning of <code>freshVariables</code>). The polytype of the last example is <span class="math inline">\(\forall F. F \rightarrow F\)</span>, for example, but it would be nicer if <code>polytypeOf</code> returned <span class="math inline">\(\forall A. A \rightarrow A\)</span>.</li>
<li>Extend the language using other simple types and operations for them.</li>
</ol>
<p>And, if you have trouble understanding some parts, try to experiment with them a lot. And feel free to ask questions on <a href="https://www.reddit.com/r/haskell/comments/h8tpfj/type_inference_introduction_to_type_systems">Reddit</a>.</p>
<h3 id="further-reading">Further reading</h3>
<p>Other resources you might find useful:</p>
<ul>
<li><a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>, Benjamin C. Pierce, Chapters 22 and 23.</li>
<li><a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"><em>Hindley-Milner type system</em></a> on Wikipedia.</li>
<li><a href="http://dev.stephendiehl.com/fun/006_hindley_milner.html"><em>Hindley-Milner inference</em></a>, chapter 6 of Stephen Diehl’s <em>Write You a Haskell</em>.</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Pierce uses the typing relation <span class="math inline">\(\Gamma \vdash t : \tau \mid_X C\)</span>, where the set <span class="math inline">\(X\)</span> keeps track of the used type variables. This is very useful to formally reason about the type inference algorithm, but it makes the typing rules more complex than necessary for a Haskell implementation. Instead, I will just write <span class="math inline">\(X \text{ fresh}\)</span> for a type variable <span class="math inline">\(X\)</span>. This approach is more informal, since it doesn’t formally specify when a variable is <em>fresh</em>, but I think it is easier.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>If you want to extend the language by having declarations, or by making a REPL, you might want to run <code>infer</code> in a specific context, so declarations aren’t lost. You would also have to run <code>gen</code> with this context, instead of an empty context.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Polymorphic lambda calculus</title>
    <link href="https://splintah.github.io/posts/2020-05-27-Polymorphic-lambda.html" />
    <id>https://splintah.github.io/posts/2020-05-27-Polymorphic-lambda.html</id>
    <published>2020-05-27T00:00:00Z</published>
    <updated>2020-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <h1>Polymorphic lambda calculus</h1>
  <section class="header">
    27 May 2020
    
  </section>
  
    <section class="series-info">
      This post is part 3 of 4 of the series <a href="/series/Introduction%20to%20Type%20Systems.html">Introduction to Type Systems</a>.
    </section>
  
  <section>
    <p>In the previous post, we have explored the simply typed lambda calculus (STLC), an extension of the untyped lambda calculus with simple types. In this post, we’ll take a look at the <em>polymorphic lambda calculus</em>, also called <em>System F</em>, an extension of the STLC with <em>polymorphism</em>.</p>
<details>
<p><summary>Imports etc.</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> <span class="dt">Polymorphic</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span>           <span class="dt">Control.Monad</span>   (when)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span>           <span class="dt">Data.Either</span>     (fromRight)</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span>           <span class="dt">Data.List</span>       (elemIndex)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">import</span>           <span class="dt">Data.Maybe</span>      (fromJust)</span></code></pre></div>
</details>
<h2 id="motivation">Motivation</h2>
<p>We have seen in the previous post how to write the identity function on booleans: <span class="math inline">\(\lambda x : \mathsf{Bool}. x\)</span>. We have also seen the identity function on boolean-to-integer functions: <span class="math inline">\(\lambda x : \mathsf{Bool} \rightarrow \mathsf{Int}. x\)</span>. As you can see, these definitions are very similar: only the type of <span class="math inline">\(x\)</span> is different, but the rest of the term is the exactly same.</p>
<p>This is suboptimal, because it means that we have duplication: in a large codebase, we may need the identity function on booleans, on integers, on boolean-to-boolean functions, on integer-to-boolean functions, etc. Not only is it annoying to write all those definitions, but what if we later realise we’ve made a mistake?<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> We have to change <em>all</em> definitions, for every type!</p>
<p>To prevent such needless labour, we want to use <em>abstraction</em>: we want to be able to write the identity function for <em>all</em> types, with only <em>one</em> definition. We will therefore extend the STLC with <a href="https://en.wikipedia.org/wiki/Parametric_polymorphism"><em>(parametric) polymorphism</em></a>. The result is called the <em>polymorphic lambda calculus</em> or <a href="https://en.wikipedia.org/wiki/System_F"><em>System F</em></a>.</p>
<h2 id="syntax">Syntax</h2>
<p>To incorporate polymorphism in the STLC, we add two new sorts of types:</p>
<ol type="1">
<li><p><em>Type variables</em>. These are just like ‘normal’, term-level variables, but instead of ranging over values, they range over types. We’ll write them with capital letters.</p></li>
<li><p><em>Polymorphic types</em>. These are written in formal syntax as <span class="math inline">\(\forall X. \tau\)</span>, where <span class="math inline">\(X\)</span> is a type variable, and <span class="math inline">\(\tau\)</span> a type. (<span class="math inline">\(\forall\)</span> is the mathematical symbol with the meaning ‘for all’.) In more Haskell-like syntax, we may write <code>forall X. τ</code>.</p>
<p>An example of a polymorphic type is <span class="math inline">\(\mathsf{id} : \forall X. X \rightarrow X\)</span>, which is the type of a function that accepts a value of any type, and returns that value. (All terms with that type turn out to be equivalent to the identity function.)</p></li>
</ol>
<p>The new syntax of types is thus:</p>
<p><span class="math display">\[
\begin{align*}
  \tau ::=\ &amp; X &amp; \text{(type variable)} \\
      \mid\ &amp; \forall X. \tau &amp; \text{(polymorphic type)} \\
      \mid\ &amp; \tau \rightarrow \tau&#39; &amp; \text{(function type)} \\
      \mid\ &amp; \mathsf{Bool} &amp; \text{(boolean type)} \\
      \mid\ &amp; \mathsf{Int} &amp; \text{(integer type)}
\end{align*}
\]</span></p>
<p>The new AST type for types looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">Type</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="ot">=</span> <span class="dt">TyVar</span> <span class="dt">String</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="co">-- ^ Type variable</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="op">|</span> <span class="dt">TyForall</span> <span class="dt">String</span> <span class="dt">Type</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">-- ^ Polymorphic type</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="op">|</span> <span class="dt">TyFun</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="co">-- ^ Function type</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="op">|</span> <span class="dt">TyBool</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="co">-- ^ Boolean type</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="op">|</span> <span class="dt">TyInt</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="co">-- ^ Integer type</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>Having updated the syntax of types, we also need to update the syntax of terms: we need terms that introduce and interact with polymorphic types. These are the terms we add:</p>
<ol type="1">
<li><p><em>Type abstractions</em>. Type abstractions are just like normal abstractions, but instead of introducing a variable that ranges over values, it introduces a type variable that ranges over types.</p>
<p>We write type abstractions with an uppercase lambda, to distinguish them from normal abstractions: <span class="math inline">\(\Lambda X. t\)</span> for a type variable <span class="math inline">\(X\)</span> and a term <span class="math inline">\(t\)</span>. In Haskell-like syntax, we write: <code>/\X. t</code>.</p>
<p>Using type abstractions, we can write the generic identity function for which we’ve seen the type above: <span class="math inline">\(\mathsf{id} = \Lambda X. \lambda x : X. x\)</span>. In the right-hand side of the type abstraction, after the period, we now can refer to <span class="math inline">\(X\)</span>, but only in types. So we can create an abstraction that accepts a parameter of type <span class="math inline">\(X\)</span>.</p></li>
<li><p><em>Type applications</em>. Type applications are used to <em>instantiate</em> a term with a specific type. If we want to use the identity function on an integer, we need to indicate that the type variable <span class="math inline">\(X\)</span> in the definition of <span class="math inline">\(\mathsf{id}\)</span> should be replaced by <span class="math inline">\(\mathsf{Int}\)</span>.</p>
<p>In formal syntax, type applications are generally written the same as normal applications: <span class="math inline">\(\mathsf{id}\ \mathsf{Int}\)</span>. But to be more explicit, we can use the Haskell syntax<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>: <code>id @Int</code>.</p></li>
</ol>
<p>We add the following to the syntax of terms:</p>
<p><span class="math display">\[
\begin{align*}
  t ::=\ &amp; \ldots \\
   \mid\ &amp; \Lambda X. t &amp; \text{(type abstraction)} \\
   \mid\ &amp; t\ \tau &amp; \text{(type application)}
\end{align*}
\]</span></p>
<p>The updated AST for terms:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Term</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="ot">=</span> <span class="dt">TmTyAbs</span> <span class="dt">String</span> <span class="dt">Term</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="co">-- ^ Type abstraction</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="op">|</span> <span class="dt">TmTyApp</span> <span class="dt">Term</span> <span class="dt">Type</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="co">-- ^ Type application</span></span></code></pre></div>
<p>The rest of the AST is exactly the same as in the STLC, but you can still see it by clicking:</p>
<details>
<p><summary>The rest of the AST definition</summary></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>  <span class="op">|</span> <span class="dt">TmTrue</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="co">-- ^ True value</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="op">|</span> <span class="dt">TmFalse</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="co">-- ^ False value</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="op">|</span> <span class="dt">TmInt</span> <span class="dt">Integer</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="co">-- ^ Integer value</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="op">|</span> <span class="dt">TmVar</span> <span class="dt">String</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="co">-- ^ Variable</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>  <span class="op">|</span> <span class="dt">TmAbs</span> <span class="dt">String</span> <span class="dt">Type</span> <span class="dt">Term</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="co">-- ^ Lambda abstraction</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>  <span class="op">|</span> <span class="dt">TmApp</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="co">-- ^ Application</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="op">|</span> <span class="dt">TmAdd</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="co">-- ^ Addition</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>  <span class="op">|</span> <span class="dt">TmIf</span> <span class="dt">Term</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>    <span class="co">-- ^ If-then-else conditional</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
</details>
<h3 id="examples">Examples</h3>
<p>Let’s look at some examples.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> We’ve already seen the polymorphic identity function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>tmId <span class="ot">=</span> <span class="dt">TmTyAbs</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>))</span></code></pre></div>
<p>And its type:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>tyId <span class="ot">=</span> <span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>))</span></code></pre></div>
<p>We can also write the <span class="math inline">\(\mathsf{const}\)</span> function, which returns its first parameter and ignores its second: <span class="math inline">\(\mathsf{const} = \Lambda A. \Lambda B. \lambda a : A. \lambda b : B. a\)</span>. In the Haskell AST:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>tmConst <span class="ot">=</span> <span class="dt">TmTyAbs</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;a&quot;</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TmAbs</span> <span class="st">&quot;b&quot;</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TmVar</span> <span class="st">&quot;a&quot;</span>))))</span></code></pre></div>
<p>And its type, <span class="math inline">\(\mathsf{const} : \forall A. \forall B. A \rightarrow B \rightarrow A\)</span>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>tyConst <span class="ot">=</span> <span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>))))</span></code></pre></div>
<p>And we can try to use <span class="math inline">\(\mathsf{const}\)</span> to return a value. The term <span class="math inline">\(\mathsf{const}\ \mathsf{Bool}\ \mathsf{Int}\ \mathsf{False}\ 5\)</span> should evaluate to <span class="math inline">\(\mathsf{False}\)</span>, so its type should be <span class="math inline">\(\mathsf{Bool}\)</span>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>tmConstFalse5 <span class="ot">=</span> <span class="dt">TmApp</span> (<span class="dt">TmApp</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmTyApp</span> tmConst <span class="dt">TyBool</span>) <span class="dt">TyInt</span>) <span class="dt">TmFalse</span>) (<span class="dt">TmInt</span> <span class="dv">5</span>)</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a>tyConstFalse5 <span class="ot">=</span> <span class="dt">TyBool</span></span></code></pre></div>
<p>Now we understand the syntax, we can move on to type checking.</p>
<h2 id="type-checking">Type checking</h2>
<p>Describing the type checking of the polymorphic lambda calculus isn’t actually that difficult. We will only add two typing rules: one for type abstractions and one for type applications. The rest of the rules will be exactly the same as those of the STLC.</p>
<p>The first rule we add is the one for type abstractions:</p>
<p><span class="math display">\[
  \text{T-TyAbs: } \frac{
    \Gamma \vdash t : \tau
  }{
    \Gamma \vdash \Lambda X. t : \forall X. \tau
  }
\]</span></p>
<p>This rule is quite simple: if <span class="math inline">\(t\)</span> has type <span class="math inline">\(\tau\)</span>, then <span class="math inline">\(\Lambda X. t\)</span> has type <span class="math inline">\(\forall X. \tau\)</span>. This is the introduction rule for polymorphic types, since it is the only typing rule that ‘produces’ a <span class="math inline">\(\forall\)</span>.</p>
<p>The rule for type applications is the elimination rule for polymorphic types: it ‘removes’ a <span class="math inline">\(\forall\)</span>. The rule is:</p>
<p><span class="math display">\[
  \text{T-TyApp: } \frac{
    \Gamma \vdash t : \forall X. \tau
  }{
    \Gamma \vdash t\ \tau&#39; : \tau[X := \tau&#39;]
  }
\]</span></p>
<p>This rule says: if <span class="math inline">\(t\)</span> has type <span class="math inline">\(\forall X. \tau\)</span>, then <span class="math inline">\(t\ \tau&#39;\)</span> (<span class="math inline">\(t\)</span> applied to type <span class="math inline">\(\tau&#39;\)</span>) has type <span class="math inline">\(\tau[X := \tau&#39;]\)</span>. This type is the result of a <em>substitution</em>; <span class="math inline">\(\tau[X := \tau&#39;]\)</span> means: substitute every free type variable <span class="math inline">\(X\)</span> in <span class="math inline">\(\tau\)</span> with <span class="math inline">\(\tau&#39;\)</span>. But, as we will see, that’s easier said than done…</p>
<p>First, let’s look at some examples of substitution:</p>
<p><span class="math display">\[
\begin{align*}
  X[X := \mathsf{Int}] &amp; \rightarrow \mathsf{Int} \\
  (X \rightarrow X)[X := \mathsf{Bool}] &amp; \rightarrow (\mathsf{Bool} \rightarrow \mathsf{Bool}) \\
  (X \rightarrow Y)[X := \mathsf{Int} \rightarrow \mathsf{Bool}] &amp; \rightarrow ((\mathsf{Int} \rightarrow \mathsf{Bool}) \rightarrow Y) \\
  (X \rightarrow (\forall X. X))[X := Y] &amp; \rightarrow (Y \rightarrow (\forall X. X))
\end{align*}
\]</span></p>
<h3 id="naïve-substitution">Naïve substitution</h3>
<p>We’ll try to write a function that performs a substitution. We write <code>subst x ty' ty</code> for <span class="math inline">\(\mathit{ty}[x := \mathit{ty&#39;}]\)</span>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">subst ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p>Defining <code>subst</code> for the simple types is easy, because they do not contain any free variables.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a>subst x ty&#39; <span class="dt">TyBool</span> <span class="ot">=</span> <span class="dt">TyBool</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>subst x ty&#39; <span class="dt">TyInt</span>  <span class="ot">=</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>Applying a substitution to a function type is also not that difficult: we’ll just apply the substitution to the source and to the target type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a>subst x ty&#39; (<span class="dt">TyFun</span> ty1 ty2) <span class="ot">=</span> <span class="dt">TyFun</span> (subst x ty&#39; ty1) (subst x ty&#39; ty2)</span></code></pre></div>
<p>When we come across a type variable <code>y</code>, we should replace it with <code>ty'</code> if <code>x</code> is equal to <code>y</code>. Otherwise, we keep <code>y</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>subst x ty&#39; (<span class="dt">TyVar</span> y)</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="op">|</span> x <span class="op">==</span> y    <span class="ot">=</span> ty&#39;</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">TyVar</span> y</span></code></pre></div>
<p>When we apply the substitution to a polymorphic type, we need to be careful: we only want to apply the substitution to <em>free</em> variables, and the <span class="math inline">\(\forall\)</span> binds the variables next to it. So only if the type abstraction binds a variable with a name different from <code>x</code>, we should apply the substitution to the right-hand side of the polymorphic type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>subst x ty&#39; (<span class="dt">TyForall</span> y ty)</span>
<span id="cb14-2"><a href="#cb14-2"></a>  <span class="op">|</span> x <span class="op">==</span> y    <span class="ot">=</span> <span class="dt">TyForall</span> y ty</span>
<span id="cb14-3"><a href="#cb14-3"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">TyForall</span> y (subst x ty&#39; ty)</span></code></pre></div>
<p>Let’s check some examples. Applying a substitution on simple types should do nothing:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a>subst <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>) <span class="dt">TyInt</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>  <span class="ot">=&gt;</span> <span class="dt">TyInt</span></span>
<span id="cb15-3"><a href="#cb15-3"></a></span>
<span id="cb15-4"><a href="#cb15-4"></a>subst <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>) <span class="dt">TyBool</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  <span class="ot">=&gt;</span> <span class="dt">TyBool</span></span></code></pre></div>
<p>If we apply this substitution to the type variable <code>"X"</code>, it should be replaced:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>subst <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)</span>
<span id="cb16-2"><a href="#cb16-2"></a>  <span class="ot">=&gt;</span> <span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>But if we apply it to <code>"Y"</code>, it should not be replaced:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>subst <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>) (<span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="ot">=&gt;</span> <span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span></span></code></pre></div>
<p>The substitution should only happen on polymorphic types when <code>"X"</code> is not bound:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>subst <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a>  (<span class="dt">TyForall</span> <span class="st">&quot;Y&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)))</span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="ot">=&gt;</span> <span class="dt">TyForall</span> <span class="st">&quot;Y&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span>) (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>))</span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a>subst <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>)</span>
<span id="cb18-6"><a href="#cb18-6"></a>  (<span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)))</span>
<span id="cb18-7"><a href="#cb18-7"></a>    <span class="ot">=&gt;</span> <span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>))</span></code></pre></div>
<p>Looks good, right?</p>
<p>Implementing the type checker for the added terms is now very easy:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a>typeOf ctx (<span class="dt">TmTyAbs</span> x t) <span class="ot">=</span> <span class="dt">TyForall</span> x <span class="op">&lt;$&gt;</span> typeOf ctx t</span>
<span id="cb19-2"><a href="#cb19-2"></a></span>
<span id="cb19-3"><a href="#cb19-3"></a>typeOf ctx (<span class="dt">TmTyApp</span> t1 ty2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb19-5"><a href="#cb19-5"></a>  <span class="kw">case</span> ty1 <span class="kw">of</span></span>
<span id="cb19-6"><a href="#cb19-6"></a>    <span class="dt">TyForall</span> x ty12 <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span> subst x ty2 ty12</span>
<span id="cb19-7"><a href="#cb19-7"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">TypeApplicationNonPolymorphic</span> t1 ty1</span></code></pre></div>
<p>The rest of the type checker is exactly the same as the type checker for the STLC, which we’ve developed in the previous post. You can still see it here:</p>
<details>
<p><summary>The rest of <code>typeOf</code></summary></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>typeOf ctx <span class="dt">TmTrue</span>    <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyBool</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>typeOf ctx <span class="dt">TmFalse</span>   <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyBool</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>typeOf ctx (<span class="dt">TmInt</span> n) <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyInt</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>typeOf ctx (<span class="dt">TmVar</span> x) <span class="ot">=</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>  <span class="kw">case</span> Map.lookup x ctx <span class="kw">of</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">UnboundVariable</span> x</span>
<span id="cb20-7"><a href="#cb20-7"></a>    <span class="dt">Just</span> ty <span class="ot">-&gt;</span> <span class="dt">Right</span> ty</span>
<span id="cb20-8"><a href="#cb20-8"></a>typeOf ctx (<span class="dt">TmAbs</span> x ty t) <span class="ot">=</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>  <span class="kw">let</span> ctx&#39; <span class="ot">=</span> Map.insert x ty ctx</span>
<span id="cb20-10"><a href="#cb20-10"></a>      ty&#39;  <span class="ot">=</span> typeOf ctx&#39; t</span>
<span id="cb20-11"><a href="#cb20-11"></a>   <span class="kw">in</span> <span class="dt">TyFun</span> ty <span class="op">&lt;$&gt;</span> ty&#39;</span>
<span id="cb20-12"><a href="#cb20-12"></a>typeOf ctx (<span class="dt">TmApp</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-13"><a href="#cb20-13"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb20-14"><a href="#cb20-14"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span>
<span id="cb20-15"><a href="#cb20-15"></a>  <span class="kw">case</span> ty1 <span class="kw">of</span></span>
<span id="cb20-16"><a href="#cb20-16"></a>    <span class="dt">TyFun</span> ty11 ty12 <span class="ot">-&gt;</span></span>
<span id="cb20-17"><a href="#cb20-17"></a>      <span class="kw">if</span> ty2 <span class="op">==</span> ty11</span>
<span id="cb20-18"><a href="#cb20-18"></a>        <span class="kw">then</span> <span class="dt">Right</span> ty12</span>
<span id="cb20-19"><a href="#cb20-19"></a>        <span class="kw">else</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ApplicationWrongArgumentType</span> t1 ty1 t2 ty2</span>
<span id="cb20-20"><a href="#cb20-20"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ApplicationNotFunction</span> t1 ty1</span>
<span id="cb20-21"><a href="#cb20-21"></a>typeOf ctx (<span class="dt">TmAdd</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-22"><a href="#cb20-22"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb20-23"><a href="#cb20-23"></a>  when (ty1 <span class="op">/=</span> <span class="dt">TyInt</span>) <span class="op">$</span></span>
<span id="cb20-24"><a href="#cb20-24"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">AdditionNonInteger</span> t1 ty1</span>
<span id="cb20-25"><a href="#cb20-25"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span>
<span id="cb20-26"><a href="#cb20-26"></a>  when (ty2 <span class="op">/=</span> <span class="dt">TyInt</span>) <span class="op">$</span></span>
<span id="cb20-27"><a href="#cb20-27"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">AdditionNonInteger</span> t2 ty2</span>
<span id="cb20-28"><a href="#cb20-28"></a>  <span class="dt">Right</span> <span class="dt">TyInt</span></span>
<span id="cb20-29"><a href="#cb20-29"></a>typeOf ctx (<span class="dt">TmIf</span> t1 t2 t3) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-30"><a href="#cb20-30"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb20-31"><a href="#cb20-31"></a>  when (ty1 <span class="op">/=</span> <span class="dt">TyBool</span>) <span class="op">$</span></span>
<span id="cb20-32"><a href="#cb20-32"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">NonBooleanCondition</span> t1 ty1</span>
<span id="cb20-33"><a href="#cb20-33"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span>
<span id="cb20-34"><a href="#cb20-34"></a>  ty3 <span class="ot">&lt;-</span> typeOf ctx t3</span>
<span id="cb20-35"><a href="#cb20-35"></a>  when (ty2 <span class="op">/=</span> ty3) <span class="op">$</span></span>
<span id="cb20-36"><a href="#cb20-36"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ArmsOfDifferentType</span> t2 ty2 t3 ty3</span>
<span id="cb20-37"><a href="#cb20-37"></a>  <span class="dt">Right</span> ty2</span></code></pre></div>
<p>And the other necessary definitions:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">typeOf ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeError</span> <span class="dt">Type</span></span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw">data</span> <span class="dt">TypeError</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>  <span class="ot">=</span> <span class="dt">UnboundVariable</span> <span class="dt">String</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>  <span class="op">|</span> <span class="dt">AdditionNonInteger</span> <span class="dt">Term</span> <span class="dt">Type</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>  <span class="op">|</span> <span class="dt">NonBooleanCondition</span> <span class="dt">Term</span> <span class="dt">Type</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>  <span class="op">|</span> <span class="dt">ArmsOfDifferentType</span> <span class="dt">Term</span> <span class="dt">Type</span> <span class="dt">Term</span> <span class="dt">Type</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>  <span class="op">|</span> <span class="dt">ApplicationWrongArgumentType</span> <span class="dt">Term</span> <span class="dt">Type</span> <span class="dt">Term</span> <span class="dt">Type</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>  <span class="op">|</span> <span class="dt">ApplicationNotFunction</span> <span class="dt">Term</span> <span class="dt">Type</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>  <span class="op">|</span> <span class="dt">TypeApplicationNonPolymorphic</span> <span class="dt">Term</span> <span class="dt">Type</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb21-12"><a href="#cb21-12"></a></span>
<span id="cb21-13"><a href="#cb21-13"></a><span class="kw">type</span> <span class="dt">Context</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Type</span></span></code></pre></div>
</details>
<p>We can try some examples:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a>typeOf Map.empty tmId</span>
<span id="cb22-2"><a href="#cb22-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)))</span>
<span id="cb22-3"><a href="#cb22-3"></a></span>
<span id="cb22-4"><a href="#cb22-4"></a>typeOf Map.empty tmId <span class="op">==</span> <span class="dt">Right</span> tyId</span>
<span id="cb22-5"><a href="#cb22-5"></a> <span class="ot">=&gt;</span> <span class="dt">True</span></span>
<span id="cb22-6"><a href="#cb22-6"></a></span>
<span id="cb22-7"><a href="#cb22-7"></a>typeOf Map.empty tmConst</span>
<span id="cb22-8"><a href="#cb22-8"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>       (<span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>        (<span class="dt">TyFun</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>         (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)</span>
<span id="cb22-12"><a href="#cb22-12"></a>         (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)))))</span>
<span id="cb22-13"><a href="#cb22-13"></a></span>
<span id="cb22-14"><a href="#cb22-14"></a>typeOf Map.empty tmConst <span class="op">==</span> <span class="dt">Right</span> tyConst</span>
<span id="cb22-15"><a href="#cb22-15"></a>  <span class="ot">=&gt;</span> <span class="dt">True</span></span>
<span id="cb22-16"><a href="#cb22-16"></a></span>
<span id="cb22-17"><a href="#cb22-17"></a>typeOf Map.empty tmConstFalse5</span>
<span id="cb22-18"><a href="#cb22-18"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> <span class="dt">TyBool</span></span>
<span id="cb22-19"><a href="#cb22-19"></a></span>
<span id="cb22-20"><a href="#cb22-20"></a>typeOf Map.empty tmConstFalse5 <span class="op">==</span> <span class="dt">Right</span> tyConstFalse5</span>
<span id="cb22-21"><a href="#cb22-21"></a>  <span class="ot">=&gt;</span> <span class="dt">True</span></span></code></pre></div>
<p>Looks pretty good, doesn’t it? But there’s a sneaky problem, and it has to do with our definition of <code>subst</code>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Let’s say we want to write a function that flips the type arguments of <span class="math inline">\(\mathsf{const}\)</span>, so <span class="math inline">\(\Lambda A. \Lambda B. \lambda a : A. \lambda b : B. a\)</span> should become <span class="math inline">\(\Lambda A. \Lambda B. \lambda a : B. \lambda b : A. a\)</span>. And we’re going to write it using the definition of <span class="math inline">\(\mathsf{const}\)</span> we’ve already written. Writing this function is quite easy: <span class="math inline">\(\mathsf{constFlip} = \Lambda A. \Lambda B. \mathsf{const}\ B\ A\)</span>.</p>
<p>The type of <span class="math inline">\(\mathsf{const}\)</span> is <span class="math inline">\(\forall A. \forall B. A \rightarrow B \rightarrow A\)</span>, so what should the type of <span class="math inline">\(\mathsf{constFlip}\)</span> be? Well, that should be <span class="math inline">\(\forall A. \forall B. B \rightarrow A \rightarrow B\)</span>, right? Let’s ask our type checker:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>tmConstFlip <span class="ot">=</span> <span class="dt">TmTyAbs</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmTyApp</span> tmConst (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>)) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)))</span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a>typeOf Map.empty tmConstFlip</span>
<span id="cb24-2"><a href="#cb24-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)))))</span></code></pre></div>
<p>Let’s make that a bit nicer to read: our type checker says that <span class="math inline">\(\mathsf{constFlip}\)</span> has type <span class="math inline">\(\forall A. \forall B. A \rightarrow A \rightarrow A\)</span>.</p>
<p>What‽ That’s not right! We have lost all our <span class="math inline">\(B\)</span>’s!</p>
<p>Indeed, we’ve made a mistake, namely in our definition of <code>subst</code>. Let’s look at the type checking process of <span class="math inline">\(\mathsf{constFlip}\)</span>. The first step is:</p>
<p><span class="math display">\[
  \text{T-TyApp: } \frac{
    \Gamma \vdash \mathsf{const} : \forall A. \forall B. A \rightarrow B \rightarrow A
  }{
    \Gamma \vdash \mathsf{const}\ B : (\forall B. A \rightarrow B \rightarrow A)[A := B]
  }
\]</span></p>
<p>Applying the substitution with our definition of <code>subst</code> gives: <span class="math inline">\(\forall B. B \rightarrow B \rightarrow B\)</span>. Note that the <span class="math inline">\(B\)</span>’s that were first <span class="math inline">\(A\)</span>’s are now <em>captured</em> by the <span class="math inline">\(\forall B\)</span>, which means that they now refer to something they shouldn’t refer to!</p>
<p>The next step:</p>
<p><span class="math display">\[
  \text{T-TyApp: } \frac{
    \Gamma \vdash \mathsf{const}\ B : \forall B. B \rightarrow B \rightarrow B
  }{
    \Gamma \vdash \mathsf{const}\ B\ A : (B \rightarrow B \rightarrow B)[B := A]
  }
\]</span></p>
<p>Applying this substitution gives: <span class="math inline">\(A \rightarrow A \rightarrow A\)</span>. In the following steps, the quantifiers are added back, so our end result is: <span class="math inline">\(\forall B. \forall A. A \rightarrow A \rightarrow A\)</span>.</p>
<p>The problem we run into here, is that we should rename some type variables. We can, for example, write <span class="math inline">\(\mathsf{const}\)</span> as <span class="math inline">\(\Lambda C. \Lambda D. \lambda a : C. \lambda b : D. a\)</span>. The type is then <span class="math inline">\(\forall C. \forall D. C \rightarrow D \rightarrow C\)</span>. Now, if we type check <span class="math inline">\(\mathsf{constFlip}\)</span>, we get the right result:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a>tmConst&#39; <span class="ot">=</span> <span class="dt">TmTyAbs</span> <span class="st">&quot;C&quot;</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;D&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;a&quot;</span> (<span class="dt">TyVar</span> <span class="st">&quot;C&quot;</span>) (<span class="dt">TmAbs</span> <span class="st">&quot;b&quot;</span> (<span class="dt">TyVar</span> <span class="st">&quot;D&quot;</span>) (<span class="dt">TmVar</span> <span class="st">&quot;a&quot;</span>))))</span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a>tmConstFlip&#39; <span class="ot">=</span> <span class="dt">TmTyAbs</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmTyApp</span> tmConst&#39; (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>)) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)))</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a>typeOf Map.empty tmConstFlip&#39;</span>
<span id="cb26-2"><a href="#cb26-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>)))))</span></code></pre></div>
<p>That is <span class="math inline">\(\forall A. \forall B. B \rightarrow A \rightarrow B\)</span>, exactly what we wanted.</p>
<p>To solve this problem, we should let our <code>subst</code> function rename some type variables to <em>fresh</em> (i.e., not already used) variables. This isn’t <em>very</em> hard to implement, but there is a nicer solution that is easier to reason about.</p>
<h2 id="de-bruijn-indices">De Bruijn-indices</h2>
<p>We will use <a href="https://en.wikipedia.org/wiki/De_Bruijn_index"><em>De Bruijn-indices</em></a>. These indices will replace our type variable names, for which we used strings. Instead, we’ll use integers. The integer <span class="math inline">\(n\)</span> will refer to the <span class="math inline">\(n\)</span>th binding <span class="math inline">\(\forall\)</span>, counting outwards from the variable and starting from zero<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. So the type for <span class="math inline">\(\mathsf{const}\)</span>, which is <span class="math inline">\(\forall A. \forall B. A \rightarrow B \rightarrow A\)</span>, will be written as <span class="math inline">\(\forall. \forall. 1 \rightarrow 0 \rightarrow 1\)</span>. (We’ll actually keep the bound names in the AST: <span class="math inline">\(\forall A. \forall B. 1 \rightarrow 0 \rightarrow 1\)</span>, but that is not necessary.)</p>
<p>To apply these changes to the Haskell AST, we won’t just change <code>TyVar String</code> into <code>TyVar Int</code>, but we’ll write:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">data</span> <span class="dt">Type</span> x</span>
<span id="cb27-2"><a href="#cb27-2"></a>  <span class="ot">=</span> <span class="dt">TyVar</span> x</span>
<span id="cb27-3"><a href="#cb27-3"></a>    <span class="co">-- ^ Type variable</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>  <span class="op">|</span> <span class="dt">TyForall</span> <span class="dt">String</span> (<span class="dt">Type</span> x)</span>
<span id="cb27-5"><a href="#cb27-5"></a>    <span class="co">-- ^ Polymorphic type</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>  <span class="op">|</span> <span class="dt">TyFun</span> (<span class="dt">Type</span> x) (<span class="dt">Type</span> x)</span>
<span id="cb27-7"><a href="#cb27-7"></a>    <span class="co">-- ^ Function type</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>  <span class="op">|</span> <span class="dt">TyBool</span></span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="co">-- ^ Boolean type</span></span>
<span id="cb27-10"><a href="#cb27-10"></a>  <span class="op">|</span> <span class="dt">TyInt</span></span>
<span id="cb27-11"><a href="#cb27-11"></a>    <span class="co">-- ^ Integer type</span></span>
<span id="cb27-12"><a href="#cb27-12"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>This allows us to construct the ordinary types as well as the types with De Bruijn-indices. We choose to do this because it makes writing a parser significantly easier: the parser can return a <code>Type String</code>, and we can later turn this into a <code>Type Int</code>. The <code>deBruijn</code> function does just that:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="ot">deBruijn ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">Type</span> <span class="dt">Int</span>)</span>
<span id="cb28-2"><a href="#cb28-2"></a>deBruijn ctx (<span class="dt">TyVar</span> x) <span class="ot">=</span> <span class="kw">case</span> elemIndex x ctx <span class="kw">of</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> x</span>
<span id="cb28-4"><a href="#cb28-4"></a>    <span class="dt">Just</span> i  <span class="ot">-&gt;</span> <span class="dt">Right</span> (<span class="dt">TyVar</span> i)</span>
<span id="cb28-5"><a href="#cb28-5"></a>deBruijn ctx (<span class="dt">TyForall</span> x ty) <span class="ot">=</span> <span class="dt">TyForall</span> x <span class="op">&lt;$&gt;</span> deBruijn (x <span class="op">:</span> ctx) ty </span>
<span id="cb28-6"><a href="#cb28-6"></a>deBruijn ctx (<span class="dt">TyFun</span> ty1 ty2) <span class="ot">=</span> <span class="dt">TyFun</span> <span class="op">&lt;$&gt;</span> deBruijn ctx ty1 <span class="op">&lt;*&gt;</span> deBruijn ctx ty2</span>
<span id="cb28-7"><a href="#cb28-7"></a>deBruijn ctx <span class="dt">TyBool</span>          <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyBool</span></span>
<span id="cb28-8"><a href="#cb28-8"></a>deBruijn ctx <span class="dt">TyInt</span>           <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>The <code>deBruijn</code> function turns an ordinary type into a type with De Bruijn-indices. It walks the abstract syntax tree recursively. When it comes across a <span class="math inline">\(\forall\)</span>, it adds the bound type variable to the context, which is a list of <code>String</code>s here. When it sees a variable, it tries to find it in the context, and if it is found, it is replaced by the index of the variable in the context. If the variable is not found in the context, we return <code>Left x</code>, to indicate that the function failed because <code>x</code> was unbound.</p>
<p>We can also restore the names (because we haven’t removed the names that are bound by the <span class="math inline">\(\forall\)</span>’s)<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="ot">restore ::</span> <span class="dt">Type</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Type</span> <span class="dt">String</span>)</span>
<span id="cb29-2"><a href="#cb29-2"></a>restore <span class="ot">=</span> go []</span>
<span id="cb29-3"><a href="#cb29-3"></a> <span class="kw">where</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>  go ctx (<span class="dt">TyVar</span> i)       <span class="ot">=</span> <span class="dt">TyVar</span> <span class="op">&lt;$&gt;</span> nth i ctx</span>
<span id="cb29-5"><a href="#cb29-5"></a>  go ctx (<span class="dt">TyForall</span> x ty) <span class="ot">=</span> <span class="dt">TyForall</span> x <span class="op">&lt;$&gt;</span> go (x <span class="op">:</span> ctx) ty</span>
<span id="cb29-6"><a href="#cb29-6"></a>  go ctx (<span class="dt">TyFun</span> ty1 ty2) <span class="ot">=</span> <span class="dt">TyFun</span> <span class="op">&lt;$&gt;</span> go ctx ty1 <span class="op">&lt;*&gt;</span> go ctx ty2</span>
<span id="cb29-7"><a href="#cb29-7"></a>  go ctx <span class="dt">TyBool</span>          <span class="ot">=</span> <span class="dt">Just</span> <span class="dt">TyBool</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>  go ctx <span class="dt">TyInt</span>           <span class="ot">=</span> <span class="dt">Just</span> <span class="dt">TyInt</span></span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a>  <span class="co">-- Get the @n@th element of a list, or &#39;Nothing&#39;</span></span>
<span id="cb29-11"><a href="#cb29-11"></a>  <span class="co">-- if the length of the list is smaller than @n@.</span></span>
<span id="cb29-12"><a href="#cb29-12"></a>  <span class="co">-- As far as I can see, there is no such function</span></span>
<span id="cb29-13"><a href="#cb29-13"></a>  <span class="co">-- in base.</span></span>
<span id="cb29-14"><a href="#cb29-14"></a><span class="ot">  nth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb29-15"><a href="#cb29-15"></a>  nth n []     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb29-16"><a href="#cb29-16"></a>  nth <span class="dv">0</span> (x<span class="op">:</span>_)  <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb29-17"><a href="#cb29-17"></a>  nth n (x<span class="op">:</span>xs) <span class="ot">=</span> nth (n <span class="op">-</span> <span class="dv">1</span>) xs</span></code></pre></div>
<p>Having changed <code>Type</code>, we also need to change <code>Term</code>, since terms can contain types. Doing this is very straight-forward and quite boring, but you can view the new definition here:</p>
<details>
<p><summary>The updated <code>Term x</code></summary></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">data</span> <span class="dt">Term</span> x</span>
<span id="cb30-2"><a href="#cb30-2"></a>  <span class="ot">=</span> <span class="dt">TmTyAbs</span> <span class="dt">String</span> (<span class="dt">Term</span> x)</span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="co">-- ^ Type abstraction</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>  <span class="op">|</span> <span class="dt">TmTyApp</span> (<span class="dt">Term</span> x) (<span class="dt">Type</span> x)</span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="co">-- ^ Type application</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>  <span class="op">|</span> <span class="dt">TmTrue</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>    <span class="co">-- ^ True value</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>  <span class="op">|</span> <span class="dt">TmFalse</span></span>
<span id="cb30-9"><a href="#cb30-9"></a>    <span class="co">-- ^ False value</span></span>
<span id="cb30-10"><a href="#cb30-10"></a>  <span class="op">|</span> <span class="dt">TmInt</span> <span class="dt">Integer</span></span>
<span id="cb30-11"><a href="#cb30-11"></a>    <span class="co">-- ^ Integer value</span></span>
<span id="cb30-12"><a href="#cb30-12"></a>  <span class="op">|</span> <span class="dt">TmVar</span> <span class="dt">String</span></span>
<span id="cb30-13"><a href="#cb30-13"></a>    <span class="co">-- ^ Variable</span></span>
<span id="cb30-14"><a href="#cb30-14"></a>  <span class="op">|</span> <span class="dt">TmAbs</span> <span class="dt">String</span> (<span class="dt">Type</span> x) (<span class="dt">Term</span> x)</span>
<span id="cb30-15"><a href="#cb30-15"></a>    <span class="co">-- ^ Lambda abstraction</span></span>
<span id="cb30-16"><a href="#cb30-16"></a>  <span class="op">|</span> <span class="dt">TmApp</span> (<span class="dt">Term</span> x) (<span class="dt">Term</span> x)</span>
<span id="cb30-17"><a href="#cb30-17"></a>    <span class="co">-- ^ Application</span></span>
<span id="cb30-18"><a href="#cb30-18"></a>  <span class="op">|</span> <span class="dt">TmAdd</span> (<span class="dt">Term</span> x) (<span class="dt">Term</span> x)</span>
<span id="cb30-19"><a href="#cb30-19"></a>    <span class="co">-- ^ Addition</span></span>
<span id="cb30-20"><a href="#cb30-20"></a>  <span class="op">|</span> <span class="dt">TmIf</span> (<span class="dt">Term</span> x) (<span class="dt">Term</span> x) (<span class="dt">Term</span> x)</span>
<span id="cb30-21"><a href="#cb30-21"></a>    <span class="co">-- ^ If-then-else conditional</span></span>
<span id="cb30-22"><a href="#cb30-22"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
</details>
<p>The substitution function for types with De Bruijn-indices is as follows:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="ot">subst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dt">Int</span></span></code></pre></div>
<p>The simple types are again very simple:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a>subst x ty&#39; <span class="dt">TyBool</span> <span class="ot">=</span> <span class="dt">TyBool</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>subst x ty&#39; <span class="dt">TyInt</span>  <span class="ot">=</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>For function types, we just apply the substitution left and right:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a>subst x ty&#39; (<span class="dt">TyFun</span> ty1 ty2) <span class="ot">=</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>  <span class="dt">TyFun</span> (subst x ty&#39; ty1) (subst x ty&#39; ty2)</span></code></pre></div>
<p>When we see a variable, we only substitute it if <code>x</code> equals <code>y</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a>subst x ty&#39; (<span class="dt">TyVar</span> y)</span>
<span id="cb34-2"><a href="#cb34-2"></a>  <span class="op">|</span> x <span class="op">==</span> y    <span class="ot">=</span> ty&#39;</span>
<span id="cb34-3"><a href="#cb34-3"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">TyVar</span> y</span></code></pre></div>
<p>And here is the tricky bit. A <span class="math inline">\(\forall\)</span> binds a type variable, so to make <code>x</code> still refer to the same <span class="math inline">\(\forall\)</span> it was bound by, we need to increment it by one. But we also need to shift all free type variables in <code>ty'</code> by one, because they will otherwise be bound by a different <span class="math inline">\(\forall\)</span>. (This was the problem we ran into before and can solve using De Bruijn-indices.)</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a>subst x ty&#39; (<span class="dt">TyForall</span> y ty) <span class="ot">=</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>  <span class="dt">TyForall</span> y <span class="op">$</span> subst (x <span class="op">+</span> <span class="dv">1</span>) (shift <span class="dv">0</span> <span class="dv">1</span> ty&#39;) ty</span></code></pre></div>
<p>Let’s look at the substitution <span class="math inline">\((\forall X. 0_X \rightarrow 2_Z)[1_Z := 0_Y]\)</span>. We’re working in a context <span class="math inline">\(Z, Y\)</span> so the term <span class="math inline">\(Z\ Y\)</span> should be written like <span class="math inline">\(1_Z\ 0_Y\)</span>. (I’ve added subscripts with the names to make the terms easier to read.) When we see the <span class="math inline">\(\forall X. \ldots\)</span>, another name is bound, so <span class="math inline">\(1\)</span> no longer refers to <span class="math inline">\(Z\)</span> but to <span class="math inline">\(Y\)</span>, and <span class="math inline">\(0\)</span> no longer refers to <span class="math inline">\(Y\)</span> but to <span class="math inline">\(X\)</span>. We need to shift <span class="math inline">\(1_Z\)</span> by one, so it becomes <span class="math inline">\(2_Z\)</span>, and we need to shift <span class="math inline">\(0_Y\)</span> by one, so it becomes <span class="math inline">\(1_Y\)</span>. The above substitution is then equal to <span class="math inline">\(\forall X. (0_X \rightarrow 2_Z)[2_Z := 1_Y]\)</span>. For this substitution, we don’t need to do any shifting, so the result is <span class="math inline">\(\forall X. 0_X \rightarrow 1_Y\)</span>.</p>
<p>It becomes more complicated when we want to substitute for a polymorphic type that binds some type variables. Let’s say we’re working in the context <span class="math inline">\(Y, B\)</span> and we want to evaluate <span class="math inline">\((\forall A. A \rightarrow B)[B := \forall X. X \rightarrow Y]\)</span>. In De Bruijn-indices, this is: <span class="math inline">\((\forall A. 0_A \rightarrow 1_B)[0_B := \forall X. 0_X \rightarrow 2_Y]\)</span>. We see <span class="math inline">\(\forall A. \ldots\)</span>, so we need to shift the variables in the substitution up by one. Naïvely, we would just increment all type variables by one, so we get: <span class="math inline">\(\ldots[1 := \forall X. 1 \rightarrow 3]\)</span>. I’ve deliberately not written the subscripts, because they have changed. The <span class="math inline">\(0_X\)</span> has become a <span class="math inline">\(1_B\)</span>, so the substitution has become a different one.</p>
<p>To solve this, we need to keep track of a <em>cutoff</em> (<span class="math inline">\(c\)</span>). This value denotes the ‘depth’ of the type, that is, how many type variables are bound by <span class="math inline">\(\forall\)</span>’s. The function <code>shift c i ty</code> will shift the free type variables above a cutoff <code>c</code> by <code>i</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="ot">shift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dt">Int</span></span></code></pre></div>
<p>There are no free variables in the simple types, so there is nothing to shift:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a>shift c i <span class="dt">TyBool</span> <span class="ot">=</span> <span class="dt">TyBool</span></span>
<span id="cb37-2"><a href="#cb37-2"></a>shift c i <span class="dt">TyInt</span>  <span class="ot">=</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>We shift function types by just shifting recursively:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a>shift c i (<span class="dt">TyFun</span> ty1 ty2) <span class="ot">=</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>  <span class="dt">TyFun</span> (shift c i ty1) (shift c i ty2)</span></code></pre></div>
<p>When we see a <span class="math inline">\(\forall\)</span>, we need to increase the cutoff, since there is another bound variable introduced:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a>shift c i (<span class="dt">TyForall</span> x ty) <span class="ot">=</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>  <span class="dt">TyForall</span> x <span class="op">$</span> shift (c <span class="op">+</span> <span class="dv">1</span>) i ty</span></code></pre></div>
<p>And finally, when we come across a variable, we should only shift it when it’s free (and thus not bound). That is the case when the variable is greater than or equal to the cutoff:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a>shift c i (<span class="dt">TyVar</span> x) <span class="ot">=</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>  <span class="kw">if</span> x <span class="op">&lt;</span> c</span>
<span id="cb40-3"><a href="#cb40-3"></a>   <span class="kw">then</span> <span class="dt">TyVar</span> x</span>
<span id="cb40-4"><a href="#cb40-4"></a>   <span class="kw">else</span> <span class="dt">TyVar</span> (x <span class="op">+</span> i)</span></code></pre></div>
<p>Some examples:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a>shift <span class="dv">0</span> <span class="dv">1</span> (<span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span></span>
<span id="cb41-2"><a href="#cb41-2"></a>           (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span> <span class="co">{- bound: X -}</span>)</span>
<span id="cb41-3"><a href="#cb41-3"></a>                  (<span class="dt">TyVar</span> <span class="dv">1</span> <span class="co">{- free -}</span>)))</span>
<span id="cb41-4"><a href="#cb41-4"></a>  <span class="ot">=&gt;</span> <span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">2</span>))</span>
<span id="cb41-5"><a href="#cb41-5"></a></span>
<span id="cb41-6"><a href="#cb41-6"></a>shift <span class="dv">0</span> <span class="dv">1</span> (<span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;Y&quot;</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>           (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span> <span class="co">{- bound: X -}</span>)</span>
<span id="cb41-8"><a href="#cb41-8"></a>                  (<span class="dt">TyVar</span> <span class="dv">1</span> <span class="co">{- bound: Y -}</span>))))</span>
<span id="cb41-9"><a href="#cb41-9"></a>  <span class="ot">=&gt;</span> <span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;Y&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">1</span>)))</span></code></pre></div>
<p>And let’s try the substitutions we’ve seen above. <span class="math inline">\((\forall X. 0_X \rightarrow 2_Z)[1_Z := 0_Y]\)</span>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a>subst <span class="dv">1</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">2</span>)))</span>
<span id="cb42-2"><a href="#cb42-2"></a>  <span class="ot">=&gt;</span> <span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">1</span>))</span></code></pre></div>
<p>That is: <span class="math inline">\(\forall X. 0_X \rightarrow 1_Y\)</span>.</p>
<p>And <span class="math inline">\((\forall A. 0_A \rightarrow 1_B)[0_B := \forall X. 0_X \rightarrow 2_Y]\)</span>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a>subst <span class="dv">0</span> (<span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">2</span>))) (<span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">1</span>)))</span>
<span id="cb43-2"><a href="#cb43-2"></a>  <span class="ot">=&gt;</span> <span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">3</span>))))</span></code></pre></div>
<p>That is: <span class="math inline">\(\forall A. 0_A \rightarrow (\forall X. 0_X \rightarrow 3_Y)\)</span>.</p>
<h2 id="type-checking-again">Type checking, again</h2>
<p>Now we have written our definition of substitutions, we can <em>almost</em> move on to implementing the type checker. But first, we need to turn the <code>Term String</code>s into <code>Term Int</code>s. Note that we only use De Bruijn-indices for types, so terms still use variables with a string name:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="ot">deBruijnTerm ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">Term</span> <span class="dt">Int</span>)</span>
<span id="cb44-2"><a href="#cb44-2"></a>deBruijnTerm ctx <span class="dt">TmTrue</span> <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TmTrue</span></span>
<span id="cb44-3"><a href="#cb44-3"></a>deBruijnTerm ctx <span class="dt">TmFalse</span> <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TmFalse</span></span>
<span id="cb44-4"><a href="#cb44-4"></a>deBruijnTerm ctx (<span class="dt">TmInt</span> n) <span class="ot">=</span> <span class="dt">Right</span> (<span class="dt">TmInt</span> n)</span>
<span id="cb44-5"><a href="#cb44-5"></a>deBruijnTerm ctx (<span class="dt">TmVar</span> x) <span class="ot">=</span> <span class="dt">Right</span> (<span class="dt">TmVar</span> x)</span></code></pre></div>
<p>Type abstractions introduce a type variable, so we should add it to the context:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a>deBruijnTerm ctx (<span class="dt">TmTyAbs</span> x t) <span class="ot">=</span> <span class="dt">TmTyAbs</span> x <span class="op">&lt;$&gt;</span> deBruijnTerm (x <span class="op">:</span> ctx) t</span>
<span id="cb45-2"><a href="#cb45-2"></a>deBruijnTerm ctx (<span class="dt">TmTyApp</span> t ty) <span class="ot">=</span> <span class="dt">TmTyApp</span> <span class="op">&lt;$&gt;</span> deBruijnTerm ctx t <span class="op">&lt;*&gt;</span> deBruijn ctx ty</span>
<span id="cb45-3"><a href="#cb45-3"></a>deBruijnTerm ctx (<span class="dt">TmAbs</span> x ty t) <span class="ot">=</span> <span class="dt">TmAbs</span> x <span class="op">&lt;$&gt;</span> deBruijn ctx ty <span class="op">&lt;*&gt;</span> deBruijnTerm ctx t</span>
<span id="cb45-4"><a href="#cb45-4"></a>deBruijnTerm ctx (<span class="dt">TmApp</span> t1 t2) <span class="ot">=</span> <span class="dt">TmApp</span> <span class="op">&lt;$&gt;</span> deBruijnTerm ctx t1 <span class="op">&lt;*&gt;</span> deBruijnTerm ctx t2</span>
<span id="cb45-5"><a href="#cb45-5"></a>deBruijnTerm ctx (<span class="dt">TmAdd</span> t1 t2) <span class="ot">=</span> <span class="dt">TmAdd</span> <span class="op">&lt;$&gt;</span> deBruijnTerm ctx t1 <span class="op">&lt;*&gt;</span> deBruijnTerm ctx t2</span>
<span id="cb45-6"><a href="#cb45-6"></a>deBruijnTerm ctx (<span class="dt">TmIf</span> t1 t2 t3) <span class="ot">=</span> <span class="dt">TmIf</span> <span class="op">&lt;$&gt;</span> deBruijnTerm ctx t1 <span class="op">&lt;*&gt;</span> deBruijnTerm ctx t2 <span class="op">&lt;*&gt;</span> deBruijnTerm ctx t3</span></code></pre></div>
<p>Some examples:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a>deBruijnTerm [] tmId</span>
<span id="cb46-2"><a href="#cb46-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)))</span>
<span id="cb46-3"><a href="#cb46-3"></a></span>
<span id="cb46-4"><a href="#cb46-4"></a>deBruijnTerm [] tmConst</span>
<span id="cb46-5"><a href="#cb46-5"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;a&quot;</span> (<span class="dt">TyVar</span> <span class="dv">1</span>) (<span class="dt">TmAbs</span> <span class="st">&quot;b&quot;</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TmVar</span> <span class="st">&quot;a&quot;</span>)))))</span>
<span id="cb46-6"><a href="#cb46-6"></a></span>
<span id="cb46-7"><a href="#cb46-7"></a>deBruijnTerm [] tmConstFlip</span>
<span id="cb46-8"><a href="#cb46-8"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;a&quot;</span> (<span class="dt">TyVar</span> <span class="dv">1</span>) (<span class="dt">TmAbs</span> <span class="st">&quot;b&quot;</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TmVar</span> <span class="st">&quot;a&quot;</span>))))) (<span class="dt">TyVar</span> <span class="dv">0</span>)) (<span class="dt">TyVar</span> <span class="dv">1</span>))))</span></code></pre></div>
<p>Now we can implement the type checker:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">type</span> <span class="dt">Context</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> (<span class="dt">Type</span> <span class="dt">Int</span>)</span>
<span id="cb47-2"><a href="#cb47-2"></a></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="ot">typeOf ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">TypeError</span> <span class="dt">Int</span>) (<span class="dt">Type</span> <span class="dt">Int</span>)</span></code></pre></div>
<details>
<p><summary>The definition of <code>TypeError</code></summary></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">data</span> <span class="dt">TypeError</span> x</span></code></pre></div>
<p>The variable was not bound by a lambda abstraction.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1"></a>  <span class="ot">=</span> <span class="dt">UnboundVariable</span> <span class="dt">String</span></span></code></pre></div>
<p>An operand of an addition term was not an integer.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a>  <span class="op">|</span> <span class="dt">AdditionNonInteger</span> (<span class="dt">Term</span> x) (<span class="dt">Type</span> x)</span></code></pre></div>
<p>The condition of an if-then-else term is not a boolean.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a>  <span class="op">|</span> <span class="dt">NonBooleanCondition</span> (<span class="dt">Term</span> x) (<span class="dt">Type</span> x)</span></code></pre></div>
<p>The arms of an if-then-else term have different types.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a>  <span class="op">|</span> <span class="dt">ArmsOfDifferentType</span> (<span class="dt">Term</span> x) (<span class="dt">Type</span> x) (<span class="dt">Term</span> x) (<span class="dt">Type</span> x)</span></code></pre></div>
<p>A function is applied to an argument of the wrong type.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a>  <span class="op">|</span> <span class="dt">ApplicationWrongArgumentType</span> (<span class="dt">Term</span> x) (<span class="dt">Type</span> x) (<span class="dt">Term</span> x) (<span class="dt">Type</span> x)</span></code></pre></div>
<p>A term of a non-function type is the left part of an application.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a>  <span class="op">|</span> <span class="dt">ApplicationNotFunction</span> (<span class="dt">Term</span> x) (<span class="dt">Type</span> x)</span></code></pre></div>
<p>A type is applied to a term with a non-polymorphic type.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a>  <span class="op">|</span> <span class="dt">TypeApplicationNonPolymorphic</span> (<span class="dt">Term</span> x) (<span class="dt">Type</span> x)</span>
<span id="cb55-2"><a href="#cb55-2"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</details>
<p>Type checking a type abstraction is still pretty simple:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a>typeOf ctx (<span class="dt">TmTyAbs</span> x t) <span class="ot">=</span> <span class="dt">TyForall</span> x <span class="op">&lt;$&gt;</span> typeOf ctx t</span></code></pre></div>
<p>But type checking a type application is a bit more involved. We don’t just apply the substitution, but do some shifting around it. With the pattern matching, we assert that <code>ty1</code> is of the form <span class="math inline">\(\forall X. \mathsf{ty12}\)</span> for some type variable <span class="math inline">\(X\)</span> and some type <span class="math inline">\(\mathsf{ty12}\)</span>. We need to shift <span class="math inline">\(\mathsf{ty2}\)</span> up, because its context is one smaller than the context of <span class="math inline">\(\mathsf{ty12}\)</span>. And we need to shift <span class="math inline">\(\mathsf{ty12}\)</span> one down after the substitution, because we have removed <span class="math inline">\(X\)</span> from the context by pattern matching on <code>ty1</code>:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1"></a>typeOf ctx (<span class="dt">TmTyApp</span> t1 ty2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb57-3"><a href="#cb57-3"></a>  <span class="kw">case</span> ty1 <span class="kw">of</span></span>
<span id="cb57-4"><a href="#cb57-4"></a>    <span class="dt">TyForall</span> x ty12 <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span></span>
<span id="cb57-5"><a href="#cb57-5"></a>      shift <span class="dv">0</span> (<span class="op">-</span><span class="dv">1</span>) (subst <span class="dv">0</span> (shift <span class="dv">0</span> <span class="dv">1</span> ty2) ty12)</span>
<span id="cb57-6"><a href="#cb57-6"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">TypeApplicationNonPolymorphic</span> t1 ty1</span></code></pre></div>
<p>Most of <code>typeOf</code> is still the same:</p>
<details>
<p><summary>Most of <code>typeOf</code></summary></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1"></a>typeOf ctx <span class="dt">TmTrue</span>    <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyBool</span></span>
<span id="cb58-2"><a href="#cb58-2"></a>typeOf ctx <span class="dt">TmFalse</span>   <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyBool</span></span>
<span id="cb58-3"><a href="#cb58-3"></a>typeOf ctx (<span class="dt">TmInt</span> n) <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyInt</span></span>
<span id="cb58-4"><a href="#cb58-4"></a>typeOf ctx (<span class="dt">TmVar</span> x) <span class="ot">=</span></span>
<span id="cb58-5"><a href="#cb58-5"></a>  <span class="kw">case</span> Map.lookup x ctx <span class="kw">of</span></span>
<span id="cb58-6"><a href="#cb58-6"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">UnboundVariable</span> x</span>
<span id="cb58-7"><a href="#cb58-7"></a>    <span class="dt">Just</span> ty <span class="ot">-&gt;</span> <span class="dt">Right</span> ty</span>
<span id="cb58-8"><a href="#cb58-8"></a>typeOf ctx (<span class="dt">TmAbs</span> x ty t) <span class="ot">=</span></span>
<span id="cb58-9"><a href="#cb58-9"></a>  <span class="kw">let</span> ctx&#39; <span class="ot">=</span> Map.insert x ty ctx</span>
<span id="cb58-10"><a href="#cb58-10"></a>      ty&#39;  <span class="ot">=</span> typeOf ctx&#39; t</span>
<span id="cb58-11"><a href="#cb58-11"></a>   <span class="kw">in</span> <span class="dt">TyFun</span> ty <span class="op">&lt;$&gt;</span> ty&#39;</span>
<span id="cb58-12"><a href="#cb58-12"></a>typeOf ctx (<span class="dt">TmAdd</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb58-13"><a href="#cb58-13"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb58-14"><a href="#cb58-14"></a>  when (ty1 <span class="op">/=</span> <span class="dt">TyInt</span>) <span class="op">$</span></span>
<span id="cb58-15"><a href="#cb58-15"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">AdditionNonInteger</span> t1 ty1</span>
<span id="cb58-16"><a href="#cb58-16"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span>
<span id="cb58-17"><a href="#cb58-17"></a>  when (ty2 <span class="op">/=</span> <span class="dt">TyInt</span>) <span class="op">$</span></span>
<span id="cb58-18"><a href="#cb58-18"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">AdditionNonInteger</span> t2 ty2</span>
<span id="cb58-19"><a href="#cb58-19"></a>  <span class="dt">Right</span> <span class="dt">TyInt</span></span></code></pre></div>
</details>
<p>But we also have to update how we type check normal applications and if-then-else terms. To check whether the argument type matches the parameter type of the left-hand side, we test whether they are equal. Similarly, for if-then-else terms we check whether the types of the arms are equal. But the <code>Eq</code> instance for <code>Type</code>s is derived, so two polymorphic types <code>TyForall x ty1</code> and <code>TyForall y ty2</code> are equal if and only if <code>x == y</code> and <code>ty1 == ty2</code>. But <span class="math inline">\(\forall X. 0_X\)</span> and <span class="math inline">\(\forall Y. 0_Y\)</span> are clearly the same type. So we can just ignore the first parameter of <code>TyForall</code> when comparing them since we are using De Bruijn-indices which don’t have to be renamed. We’ll use the <code>tyEq</code> function for testing whether two types are equal<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1"></a>typeOf ctx (<span class="dt">TmApp</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb59-3"><a href="#cb59-3"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span>
<span id="cb59-4"><a href="#cb59-4"></a>  <span class="kw">case</span> ty1 <span class="kw">of</span></span>
<span id="cb59-5"><a href="#cb59-5"></a>    <span class="dt">TyFun</span> ty11 ty12 <span class="ot">-&gt;</span></span>
<span id="cb59-6"><a href="#cb59-6"></a>      <span class="kw">if</span> tyEq ty2 ty11</span>
<span id="cb59-7"><a href="#cb59-7"></a>        <span class="kw">then</span> <span class="dt">Right</span> ty12</span>
<span id="cb59-8"><a href="#cb59-8"></a>        <span class="kw">else</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ApplicationWrongArgumentType</span> t1 ty1 t2 ty2</span>
<span id="cb59-9"><a href="#cb59-9"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ApplicationNotFunction</span> t1 ty1</span>
<span id="cb59-10"><a href="#cb59-10"></a></span>
<span id="cb59-11"><a href="#cb59-11"></a>typeOf ctx (<span class="dt">TmIf</span> t1 t2 t3) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb59-12"><a href="#cb59-12"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb59-13"><a href="#cb59-13"></a>  when (ty1 <span class="op">/=</span> <span class="dt">TyBool</span>) <span class="op">$</span></span>
<span id="cb59-14"><a href="#cb59-14"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">NonBooleanCondition</span> t1 ty1</span>
<span id="cb59-15"><a href="#cb59-15"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span>
<span id="cb59-16"><a href="#cb59-16"></a>  ty3 <span class="ot">&lt;-</span> typeOf ctx t3</span>
<span id="cb59-17"><a href="#cb59-17"></a>  when (<span class="fu">not</span> (tyEq ty2 ty3)) <span class="op">$</span></span>
<span id="cb59-18"><a href="#cb59-18"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ArmsOfDifferentType</span> t2 ty2 t3 ty3</span>
<span id="cb59-19"><a href="#cb59-19"></a>  <span class="dt">Right</span> ty2</span>
<span id="cb59-20"><a href="#cb59-20"></a></span>
<span id="cb59-21"><a href="#cb59-21"></a><span class="ot">tyEq ::</span> <span class="dt">Type</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb59-22"><a href="#cb59-22"></a>tyEq (<span class="dt">TyVar</span> x) (<span class="dt">TyVar</span> y)                 <span class="ot">=</span> x <span class="op">==</span> y</span>
<span id="cb59-23"><a href="#cb59-23"></a>tyEq (<span class="dt">TyForall</span> _ ty1) (<span class="dt">TyForall</span> _ ty2)   <span class="ot">=</span> tyEq ty1 ty2</span>
<span id="cb59-24"><a href="#cb59-24"></a>tyEq (<span class="dt">TyFun</span> ty11 ty12) (<span class="dt">TyFun</span> ty21 ty22) <span class="ot">=</span> tyEq ty11 ty21 <span class="op">&amp;&amp;</span> tyEq ty12 ty22</span>
<span id="cb59-25"><a href="#cb59-25"></a>tyEq <span class="dt">TyBool</span> <span class="dt">TyBool</span>                       <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb59-26"><a href="#cb59-26"></a>tyEq <span class="dt">TyInt</span> <span class="dt">TyInt</span>                         <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb59-27"><a href="#cb59-27"></a>tyEq _ _                                 <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>And with that, we should have a working type checker for the polymorphic lambda calculus! Let’s try it:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">let</span> <span class="dt">Right</span> tmConstDB <span class="ot">=</span> deBruijnTerm [] tmConst</span>
<span id="cb60-2"><a href="#cb60-2"></a> <span class="kw">in</span> typeOf Map.empty tmConstDB</span>
<span id="cb60-3"><a href="#cb60-3"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">1</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">1</span>)))))</span></code></pre></div>
<p>We can also <code>restore</code> the term:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1"></a><span class="kw">let</span> <span class="dt">Right</span> tmDB <span class="ot">=</span> deBruijnTerm [] tmConst</span>
<span id="cb61-2"><a href="#cb61-2"></a>    <span class="dt">Right</span> ty   <span class="ot">=</span> typeOf Map.empty tmDB</span>
<span id="cb61-3"><a href="#cb61-3"></a> <span class="kw">in</span> restore ty</span>
<span id="cb61-4"><a href="#cb61-4"></a>  <span class="ot">=&gt;</span> <span class="dt">Just</span> (<span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span></span>
<span id="cb61-5"><a href="#cb61-5"></a>           (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)</span>
<span id="cb61-6"><a href="#cb61-6"></a>                  (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>)</span>
<span id="cb61-7"><a href="#cb61-7"></a>                         (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)))))</span></code></pre></div>
<p><span class="math inline">\(\mathsf{const} : \forall A. \forall B. A \rightarrow B \rightarrow A\)</span>, just what we expected!</p>
<p>Now let’s try <span class="math inline">\(\mathsf{constFlip}\)</span>, which failed previously:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">let</span> <span class="dt">Right</span> tmDB <span class="ot">=</span> deBruijnTerm [] tmConstFlip</span>
<span id="cb62-2"><a href="#cb62-2"></a>    <span class="dt">Right</span> ty   <span class="ot">=</span> typeOf Map.empty tmDB</span>
<span id="cb62-3"><a href="#cb62-3"></a> <span class="kw">in</span> restore ty</span>
<span id="cb62-4"><a href="#cb62-4"></a>  <span class="ot">=&gt;</span> <span class="dt">Just</span> (<span class="dt">TyForall</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span></span>
<span id="cb62-5"><a href="#cb62-5"></a>           (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>)</span>
<span id="cb62-6"><a href="#cb62-6"></a>                  (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)</span>
<span id="cb62-7"><a href="#cb62-7"></a>                         (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>)))))</span></code></pre></div>
<p><span class="math inline">\(\mathsf{constFlip} : \forall A. \forall B. B \rightarrow A \rightarrow B\)</span>, hurray!</p>
<p>And let’s also check that we can apply polymorphic functions, <span class="math inline">\((\lambda \mathsf{id} : (\forall X. X \rightarrow X). \mathsf{id}\ \mathsf{Int}\ 6)\ (\Lambda Y. \lambda y : Y. y)\)</span>:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">let</span> tm <span class="ot">=</span> <span class="dt">TmApp</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>           (<span class="dt">TmAbs</span> <span class="st">&quot;id&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)))</span>
<span id="cb63-3"><a href="#cb63-3"></a>             (<span class="dt">TmApp</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) <span class="dt">TyInt</span>) (<span class="dt">TmInt</span> <span class="dv">6</span>)))</span>
<span id="cb63-4"><a href="#cb63-4"></a>           (<span class="dt">TmTyAbs</span> <span class="st">&quot;Y&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;y&quot;</span> (<span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span>) (<span class="dt">TmVar</span> <span class="st">&quot;y&quot;</span>)))</span>
<span id="cb63-5"><a href="#cb63-5"></a>    <span class="dt">Right</span> tmDB <span class="ot">=</span> deBruijnTerm [] tm</span>
<span id="cb63-6"><a href="#cb63-6"></a>    <span class="dt">Right</span> ty <span class="ot">=</span> typeOf Map.empty tmDB</span>
<span id="cb63-7"><a href="#cb63-7"></a> <span class="kw">in</span> ty</span>
<span id="cb63-8"><a href="#cb63-8"></a>  <span class="ot">=&gt;</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>Cool! (Writing this example, I wished I had written a parser…)</p>
<p>Note, however, that restoring does not always work:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">let</span> tm <span class="ot">=</span> <span class="dt">TmTyAbs</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmTyApp</span> tmConst (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>))</span>
<span id="cb64-2"><a href="#cb64-2"></a>    <span class="dt">Right</span> tmDB <span class="ot">=</span> deBruijnTerm [] tm</span>
<span id="cb64-3"><a href="#cb64-3"></a>    <span class="dt">Right</span> ty <span class="ot">=</span> typeOf Map.empty tmDB</span>
<span id="cb64-4"><a href="#cb64-4"></a> <span class="kw">in</span> (ty, restore ty)</span>
<span id="cb64-5"><a href="#cb64-5"></a>  <span class="ot">=&gt;</span> ( <span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">1</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="dv">0</span>) (<span class="dt">TyVar</span> <span class="dv">1</span>))))</span>
<span id="cb64-6"><a href="#cb64-6"></a>     , <span class="dt">Just</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TyForall</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>)))))</span>
<span id="cb64-7"><a href="#cb64-7"></a>     )</span></code></pre></div>
<p>The first type, using De Bruijn-indices, is correct: <span class="math inline">\(\forall B. \forall B. 1_B \rightarrow 0_B \rightarrow 1_B\)</span>. The second, restored type, however, is: <span class="math inline">\(\forall B. \forall B. B \rightarrow B \rightarrow B\)</span>. If we turn this into a <code>Type Int</code>, we get <span class="math inline">\(\forall B. \forall B. 0_B \rightarrow 0_B \rightarrow 0_B\)</span>, which is not equal to the original. To solve this, you would need to do some renaming.</p>
<p>Some more examples:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1"></a><span class="ot">everything ::</span> <span class="dt">Term</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dt">String</span></span>
<span id="cb65-2"><a href="#cb65-2"></a>everything <span class="ot">=</span> fromJust <span class="op">.</span> restore <span class="op">.</span> fromRight oops <span class="op">.</span> typeOf Map.empty <span class="op">.</span> fromRight oops <span class="op">.</span> deBruijnTerm []</span>
<span id="cb65-3"><a href="#cb65-3"></a> <span class="kw">where</span></span>
<span id="cb65-4"><a href="#cb65-4"></a>  oops <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;everything: expected Right but found Left&quot;</span></span></code></pre></div>
<p><span class="math inline">\(\mathsf{id}\ \mathsf{Bool}\ \mathsf{True}\)</span>:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1"></a>everything (<span class="dt">TmApp</span> (<span class="dt">TmTyApp</span> tmId <span class="dt">TyBool</span>) <span class="dt">TmTrue</span>)</span>
<span id="cb66-2"><a href="#cb66-2"></a>  <span class="ot">=&gt;</span> <span class="dt">TyBool</span></span></code></pre></div>
<p><span class="math inline">\(\mathsf{const}\ \mathsf{Int}\ (\mathsf{Int} \rightarrow \mathsf{Bool})\ (10 + 20)\ (\mathsf{const}\ \mathsf{Bool}\ \mathsf{Int}\ \mathsf{False})\)</span>:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1"></a>everything (<span class="dt">TmApp</span> (<span class="dt">TmApp</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmTyApp</span> tmConst <span class="dt">TyInt</span>) (<span class="dt">TyFun</span> <span class="dt">TyInt</span> <span class="dt">TyBool</span>)) (<span class="dt">TmAdd</span> (<span class="dt">TmInt</span> <span class="dv">10</span>) (<span class="dt">TmInt</span> <span class="dv">20</span>))) (<span class="dt">TmApp</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmTyApp</span> tmConst <span class="dt">TyBool</span>) <span class="dt">TyInt</span>) <span class="dt">TmFalse</span>))</span>
<span id="cb67-2"><a href="#cb67-2"></a>  <span class="ot">=&gt;</span> <span class="dt">TyInt</span></span></code></pre></div>
<p><span class="math inline">\((\mathbf{if}\ \mathsf{False}\ \mathbf{then}\ (\Lambda A. \lambda a : A. a)\ \mathbf{else}\ (\Lambda B. \lambda b : B. b))\ \mathsf{Int}\ 5\)</span></p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1"></a>everything (<span class="dt">TmApp</span> (<span class="dt">TmTyApp</span> (<span class="dt">TmIf</span> <span class="dt">TmFalse</span> (<span class="dt">TmTyAbs</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;a&quot;</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;a&quot;</span>)))) (<span class="dt">TmTyAbs</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;b&quot;</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;b&quot;</span>))))) <span class="dt">TyInt</span>) (<span class="dt">TyInt</span> <span class="dv">5</span>))</span>
<span id="cb68-2"><a href="#cb68-2"></a>  <span class="ot">=&gt;</span> <span class="dt">TyInt</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>We have explored the polymorphic lambda calculus (or System F), which allows for more abstraction than the simply typed lambda calculus. We have met the trouble of substitution, and we have seen how we can solve it using De Bruijn-indices.</p>
<p>Most <a href="/posts/2020-05-24-Simply-typed-lambda.html#conclusion">exercises for the STLC</a> can also be applied to the polymorphic lambda calculus. Some other exercises:</p>
<ol type="1">
<li>Add a pair type (tuple with two elements) with a constructor (you could use <span class="math inline">\((t, t&#39;)\)</span> if you’re writing a parser; otherwise it doesn’t really matter for the abstract syntax tree) and <code>fst</code> and <code>snd</code> to project elements out of the pair. Write the typing rules and extend the type checker.</li>
<li>Write a <code>restore</code> function that works on all types with De Bruijn-indices. You would need to keep track of the context, i.e., what type variables are used. And you need to be able to generate fresh type variables; you can try to add primes (<code>'</code>) to the first parameter of <code>TyForall</code> until the name is not bound in the context, for example.</li>
</ol>
<p>In the next post, I will explore <em>type inference</em>, which will allow us to eliminate <em>all</em> types in the syntax of terms. No more <span class="math inline">\(\mathsf{const} = \Lambda A. \Lambda B. \lambda a : A. \lambda b : B. a\)</span>, but just <span class="math inline">\(\mathsf{const} = \lambda a. \lambda b. a\)</span>. And instead of <span class="math inline">\(\mathsf{const}\ \mathsf{Int}\ \mathsf{Bool}\ 19\ \mathsf{True}\)</span>, we will write just <span class="math inline">\(\mathsf{const}\ 19\ \mathsf{True}\)</span>.</p>
<h3 id="further-reading">Further reading</h3>
<p>If you want to read more about De Bruijn-indices, shifting and substitution, you might find the following resources useful:</p>
<ul>
<li><a href="https://www.cs.cornell.edu/courses/cs4110/2018fa/lectures/lecture15.pdf"><em>CS 4110 – Programming Languages and Logics Lecture #15: De Bruijn, Combinators, Encodings</em></a></li>
<li><a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>, Benjamin C. Pierce, Chapter 6.</li>
</ul>
<p>These resources are about using De Bruijn-indices in the untyped lambda calculus, but this knowledge can also be applied to types. If you find shifting and substitution for De Bruijn-indices a bit hard to grasp (I did when I first learnt about them), I recommend you try to work out some examples by hand.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Making a mistake writing the identity function is perhaps a bit silly. But in more complex programs, such as a sorting function, this could very well happen.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>With the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeApplications"><code>TypeApplications</code> extension</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>You might notice that I don’t specify the types of these examples, i.e., I don’t write <code>tmId :: Term</code>. I haven’t forgotten them, but I purposefully omitted them. You’ll later see why.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>There is also another problem: the definition of <code>(==)</code> for types isn’t correct. We will later fix that problem.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>It is also common to start counting from one, but since we will use lists and their indices (which in Haskell’s <code>Prelude</code> start from zero), it is more convenient to start counting from zero.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>The <code>restore</code> function does not work in general, but it should work on types generated by <code>deBruijn</code>. An example that doesn’t work: <span class="math inline">\(\forall X. \forall X. 0 \rightarrow 1\)</span>. Both <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> will be replaced by <span class="math inline">\(X\)</span>, and they will both refer to the inner <span class="math inline">\(X\)</span>, but the <span class="math inline">\(1\)</span> should refer to the outer <span class="math inline">\(X\)</span>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Testing whether a type is equal to <code>TyBool</code> or <code>TyInt</code> can still be done using <code>(==)</code>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Simply typed lambda calculus</title>
    <link href="https://splintah.github.io/posts/2020-05-24-Simply-typed-lambda.html" />
    <id>https://splintah.github.io/posts/2020-05-24-Simply-typed-lambda.html</id>
    <published>2020-05-24T00:00:00Z</published>
    <updated>2020-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <h1>Simply typed lambda calculus</h1>
  <section class="header">
    24 May 2020
    
  </section>
  
    <section class="series-info">
      This post is part 2 of 4 of the series <a href="/series/Introduction%20to%20Type%20Systems.html">Introduction to Type Systems</a>.
    </section>
  
  <section>
    <p>Our exploration of type systems starts quite simple, with the <em>simply typed lambda calculus</em> (STLC). This type system is the foundation of more complex type systems such as Haskell’s. The simply typed lambda calculus is based on the <em>(untyped) lambda calculus</em>. To understand the simply typed lambda calculus, you do <em>not</em> have to understand the untyped lambda calculus, but it could be beneficial, as I will refer to some of its properties. If you want to read about the untyped lambda calculus, the following articles might be helpful:</p>
<ul>
<li><a href="https://afnan.io/posts/lambda-calculus/"><em>Lambda Calculus</em> by Afnan Enayet</a></li>
<li><a href="https://crypto.stanford.edu/~blynn/lambda/"><em>Lambda Calculus</em> by Ben Lynn</a></li>
</ul>
<details>
<p><summary>Imports etc.</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> <span class="dt">SimplyTyped</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span>           <span class="dt">Control.Monad</span>   (when)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</span></code></pre></div>
</details>
<h2 id="syntax">Syntax</h2>
<p>The syntax of a (programming) language describes how the language is written. The syntax of the simply typed lambda calculus consists of two things: <em>terms</em> and <em>types</em>.</p>
<h3 id="types">Types</h3>
<p>One major difference between the untyped lambda calculus and the simply typed, is that the latter has a notion of <em>types</em>. The STLC contains two different sorts of types:</p>
<ol type="1">
<li><em>Function types</em>. We write the type of a function that accepts a parameter of type <span class="math inline">\(\tau\)</span> and returns a value of type <span class="math inline">\(\tau&#39;\)</span> as <span class="math inline">\(\tau \rightarrow \tau&#39;\)</span>. The identity function on booleans, for example, accepts a parameter of type <span class="math inline">\(\mathsf{Bool}\)</span> (boolean), and returns a value of the same type. Its type is thus written as <span class="math inline">\(\mathsf{Bool} \rightarrow \mathsf{Bool}\)</span>. We also add that the function arrow is <em>right-associative</em>: <span class="math inline">\(\tau \rightarrow \tau&#39; \rightarrow \tau&#39;&#39;\)</span> is the same as <span class="math inline">\(\tau \rightarrow (\tau&#39; \rightarrow \tau&#39;&#39;)\)</span>.</li>
<li><em>Simple types</em> (also called <em>constant types</em>). These types are what makes the STLC the simply typed lambda calculus. The simple types are the types of the constant values: <code>True</code> has type <code>Bool</code> (boolean), <code>8</code> has type <code>Int</code> (integer), et cetera.</li>
</ol>
<p>We can choose the simple types however we like. Here, we’ll use booleans and integers, and add the if-then-else construct and addition. Adding operations like subtraction, multiplication, etc., is very straight-forward when you know how to handle addition, so I won’t explicitly explain how they work.</p>
<p>In more formal syntax, we write:</p>
<p><span class="math display">\[
\begin{align*}
  \tau ::=\ &amp; \tau \rightarrow \tau&#39; &amp; \text{(function type)} \\
      \mid\ &amp; \mathsf{Bool} &amp; \text{(boolean type)} \\
      \mid\ &amp; \mathsf{Int} &amp; \text{(integer type)}
\end{align*}
\]</span></p>
<p>You can read the symbol <span class="math inline">\(::=\)</span> as ‘<em>is defined by the following rules</em>’. The symbol <span class="math inline">\(\mid\)</span> separates rules, and you can read it as ‘<em>or</em>’. The grammar description starts with a <span class="math inline">\(\tau\)</span> (Greek letter tau, commonly used for denoting types); whenever you see a <span class="math inline">\(\tau\)</span> or a <span class="math inline">\(\tau\)</span> with any number of primes (which are used to make clear that these types may differ), it means that the syntax ‘expects’ another type there. The syntax of types is thus defined recursively. (This notation of grammars is called <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur form</a> (BNF).)</p>
<p>Translating such a syntax definition to Haskell is quite easy. We define a type called <code>Type</code>, which contains the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><em>abstract syntax tree</em></a> (AST) for types. The AST does not directly correspond to the actual syntax of the types; we don’t encode in the AST how whitespace should be handled, how comments are written, that the function arrow is right-associative, etc. That’s why it’s called an <em>abstract</em> syntax tree. The Haskell data type for the AST of types looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">Type</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="ot">=</span> <span class="dt">TyFun</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="co">-- ^ Function type. The type @TyFun ty1 ty2@</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="co">-- corresponds to @ty1 -&gt; ty2@.</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="op">|</span> <span class="dt">TyBool</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="co">-- ^ Boolean type</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="op">|</span> <span class="dt">TyInt</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="co">-- ^ Integer type</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<h3 id="terms">Terms</h3>
<p>There are five sorts of terms in the STLC. These are based on the terms of the untyped lambda calculus, with some additions: the syntax for lambda abstractions is a bit different and values and computation constructs are added. The terms of the STLC consist of:</p>
<ol type="1">
<li><p><em>Variables</em>. These are names for values. We generally use strings of characters as variable names, but we could just as well use integers<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>What strings are valid variable names is not very important here, since we aren’t writing a parser. Variable names generally consist of alphanumeric characters, starting with an alphabetic character. We’ll use this as an informal rule.</p></li>
<li><p><em>(Lambda) abstractions</em>. Lambda abstractions (or in short: abstractions) are functions. They accept one<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> parameter and return a value. We write them like in the untyped lambda calculus, but add the type of the parameter.</p>
<p>The identity function on booleans, <span class="math inline">\(\mathsf{id}_\mathsf{Bool}\)</span>, for example, is written like <span class="math inline">\(\lambda x : \mathsf{Bool}. x\)</span>. (Or, in more Haskell-like syntax: <code>\x : Bool. x</code>.) This function accepts a boolean parameter named <span class="math inline">\(x\)</span>. In the return value (which is written after the period), we can use the variable name <span class="math inline">\(x\)</span> to refer to the value that was <em>bound</em> (i.e., introduced) by the abstraction.</p></li>
<li><p><em>Applications</em>. This is just function application. We write it using juxtaposition: <span class="math inline">\(f\)</span> applied to <span class="math inline">\(x\)</span> is written as <span class="math inline">\(f\ x\)</span>. Applications only really make sense when the left value is an abstraction (or a term that evaluates to one).</p></li>
<li><p><em>(Constant) values</em>. These are values like integers (<code>3</code>), booleans (<code>True</code>), characters (<code>'f'</code>) et cetera. These values cannot be evaluated any further, and are pretty useless on their own, so we also need:</p></li>
<li><p><em>Computation constructs</em>. These are terms like conditionals (<code>if a then b else c</code>), binary operations (<code>x + y</code>), et cetera. The key aspect of these constructs is that they have some sense of computation: <code>if True then a else b</code> should evaluate to <code>a</code>, <code>5 + 6</code> should evaluate to <code>11</code>. We add these terms to the lambda calculus when adding simple types, because without them, we can’t ‘do anything’ with the values we added.</p></li>
</ol>
<p>More formally, we describe the grammar of terms as follows:</p>
<p><span class="math display">\[
\begin{align*}
  t ::=\ &amp; \mathsf{False} &amp; \text{(false)} \\
   \mid\ &amp; \mathsf{True} &amp; \text{(true)} \\
   \mid\ &amp; n &amp; \text{(integer)} \\
   \mid\ &amp; x &amp; \text{(variable)} \\
   \mid\ &amp; \lambda x : \tau.\ t &amp; \text{(lambda abstraction)} \\
   \mid\ &amp; t\ t&#39; &amp; \text{(application)} \\
   \mid\ &amp; t + t&#39; &amp; \text{(addition)} \\
   \mid\ &amp; \mathbf{if}\ t\ \mathbf{then}\ t&#39;\ \mathbf{else}\ t&#39;&#39; &amp; \text{(if-then-else)}
\end{align*}
\]</span></p>
<p>We write <span class="math inline">\(x\)</span> for variables, without explicitly defining what <span class="math inline">\(x\)</span> can be. And for integers we write <span class="math inline">\(n\)</span>, also without explicitly specifying what valid values of <span class="math inline">\(n\)</span> are. That’s because, as explained above, it doesn’t really matter what set of strings we allow as variable names for reasoning about programs. And it also doesn’t matter that much whether we use 32-bit, 64-bit, signed, unsigned, or unbounded integers.</p>
<p>Again, writing the Haskell definition is quite easy:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Term</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="ot">=</span> <span class="dt">TmTrue</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="co">-- ^ True value</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="op">|</span> <span class="dt">TmFalse</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="co">-- ^ False value</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>  <span class="op">|</span> <span class="dt">TmInt</span> <span class="dt">Integer</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="co">-- ^ Integer value</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>  <span class="op">|</span> <span class="dt">TmVar</span> <span class="dt">String</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="co">-- ^ Variable</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>  <span class="op">|</span> <span class="dt">TmAbs</span> <span class="dt">String</span> <span class="dt">Type</span> <span class="dt">Term</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="co">-- ^ Lambda abstraction. @TmAbs x ty t@</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="co">-- corresponds to @\x : ty. t@.</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>  <span class="op">|</span> <span class="dt">TmApp</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="co">-- ^ Application</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>  <span class="op">|</span> <span class="dt">TmAdd</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="co">-- ^ Addition</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="op">|</span> <span class="dt">TmIf</span> <span class="dt">Term</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="co">-- ^ If-then-else conditional</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<h3 id="examples">Examples</h3>
<p>Let’s look at some examples. The abstract syntax tree of the identity function on booleans, which we’ve seen before, is written like this in Haskell:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">tmIdBool ::</span> <span class="dt">Term</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>tmIdBool <span class="ot">=</span> <span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> <span class="dt">TyBool</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)</span></code></pre></div>
<p>Another example is the <code>not</code> function, which inverts its boolean argument: <span class="math inline">\(\lambda x : \mathsf{Bool}. \mathbf{if}\ x\ \mathbf{then}\ \mathsf{False}\ \mathbf{else}\ \mathsf{True}\)</span>. In Haskell:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">tmNot ::</span> <span class="dt">Term</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>tmNot <span class="ot">=</span> <span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> <span class="dt">TyBool</span> (<span class="dt">TmIf</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>) <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>)</span></code></pre></div>
<p>A function that adds its two arguments: <span class="math inline">\(\lambda x : \mathsf{Int}. \lambda y : \mathsf{Int}. x + y\)</span>. In Haskell:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">tmAdd ::</span> <span class="dt">Term</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>tmAdd <span class="ot">=</span> <span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> <span class="dt">TyInt</span> (<span class="dt">TmAbs</span> <span class="st">&quot;y&quot;</span> <span class="dt">TyInt</span> (<span class="dt">TmAdd</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">TmVar</span> <span class="st">&quot;y&quot;</span>)))</span></code></pre></div>
<p>And its type, <span class="math inline">\(\mathsf{Int} \rightarrow \mathsf{Int} \rightarrow \mathsf{Int}\)</span>, which is the same as <span class="math inline">\(\mathsf{Int} \rightarrow (\mathsf{Int} \rightarrow \mathsf{Int})\)</span>, is in Haskell:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">tyAdd ::</span> <span class="dt">Type</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>tyAdd <span class="ot">=</span> <span class="dt">TyFun</span> <span class="dt">TyInt</span> (<span class="dt">TyFun</span> <span class="dt">TyInt</span> <span class="dt">TyInt</span>)</span></code></pre></div>
<p>Now we know the syntax of terms and types, we can move on to the relation between the two.</p>
<h2 id="type-checking">Type checking</h2>
<p>A type checker checks that all values are used correctly, i.e., that they have the right type. Type checking is useful, because it can help us spot mistakes in our program. Without a type checker, if we were to evaluate the expression <span class="math inline">\(1 + \mathsf{True}\)</span>, the program would crash; it does not make sense to add a boolean and an integer. A type checker can prevent the program from crashing, because it will reject faulty programs before they are interpreted or compiled.</p>
<p>To express that a term has a certain type, we use a <em>typing judgement</em>. The judgement will look something like this in mathematical notation: <span class="math inline">\(\Gamma \vdash t : \tau\)</span>. You can read it as: <em>the context <span class="math inline">\(\Gamma\)</span> entails that <span class="math inline">\(t\)</span> has type <span class="math inline">\(\tau\)</span></em>.</p>
<p>The <em>context</em> is a set of <em>bindings</em>: variables and their types. Contexts are generally written like this:</p>
<ul>
<li><span class="math inline">\(\varnothing\)</span> denotes the empty context;</li>
<li><span class="math inline">\(\Gamma, x : \tau\)</span> denotes the context <span class="math inline">\(\Gamma\)</span> extended with <span class="math inline">\(x\)</span> and its type <span class="math inline">\(\tau\)</span>.</li>
</ul>
<p>The context <span class="math inline">\(\varnothing, x : \mathsf{Bool}, f : \mathsf{Bool} \rightarrow \mathsf{Int}\)</span> contains two bindings: the boolean <span class="math inline">\(x\)</span> and the boolean-to-integer function <span class="math inline">\(f\)</span>.</p>
<p>We can combine typing judgements to form <em>typing rules</em>. We use <a href="https://en.wikipedia.org/wiki/Rule_of_inference"><em>inference rules</em></a> to make statements about how to reason about terms and types. These inference rules consist of a number of premises, a horizontal bar, and the conclusion. An example is <em>modus ponens</em>:</p>
<p><span class="math display">\[
  \frac{
    \begin{array}{c}
      A \\
      A \rightarrow B
    \end{array}
  }{
    B
  }
\]</span></p>
<p>You can read this as: <em>if we have <span class="math inline">\(A\)</span> and <span class="math inline">\(A \rightarrow B\)</span> </em>(if <span class="math inline">\(A\)</span> then <span class="math inline">\(B\)</span>)<em>, then we conclude <span class="math inline">\(B\)</span>.</em></p>
<p>We use this notation for typing rules. The most simple rules are the rules for boolean and integer values:</p>
<p><span class="math display">\[
  \text{T-True: } \frac{}{\varnothing \vdash \mathsf{True} : \mathsf{Bool}}
\]</span></p>
<p>T-True is the name of the rule. This rule has no premises, and states that we can conclude in an empty context that <span class="math inline">\(\mathsf{True}\)</span> has type <span class="math inline">\(\mathsf{Bool}\)</span>.</p>
<p>Instead of writing <span class="math inline">\(\varnothing \vdash t : \tau\)</span>, the <span class="math inline">\(\varnothing\)</span> is usually omitted: <span class="math inline">\(\vdash t : \tau\)</span>. So, the rule for <span class="math inline">\(\mathsf{False}\)</span> is:</p>
<p><span class="math display">\[
  \text{T-False: } \frac{}{\vdash \mathsf{False} : \mathsf{Bool}}
\]</span></p>
<p>And the rule for integers:</p>
<p><span class="math display">\[
  \text{T-Int: } \frac{}{\vdash n : \mathsf{Int}}
\]</span></p>
<p>Now let’s write some more complex rules. To find the type of variables, we look them up in the context. To denote that <span class="math inline">\(x\)</span> has type <span class="math inline">\(\tau\)</span> in <span class="math inline">\(\Gamma\)</span>, we write: <span class="math inline">\(x : \tau \in \Gamma\)</span>. So, the rule for variables is:</p>
<p><span class="math display">\[
  \text{T-Var: } \frac{
    x : \tau \in \Gamma
  }{
    \Gamma \vdash x : \tau
  }
\]</span></p>
<p>The rule for lambda abstractions looks like this:</p>
<p><span class="math display">\[
  \text{T-Abs: } \frac{
    \Gamma, x : \tau \vdash t : \tau&#39;
  }{
    \Gamma \vdash \lambda x : \tau. t : \tau \rightarrow \tau&#39;
  }
\]</span></p>
<p>To type check abstractions, we add <span class="math inline">\(x : \tau\)</span> to the context (because <span class="math inline">\(t\)</span> might use <span class="math inline">\(x\)</span>) and check the type of <span class="math inline">\(t\)</span>. We then know that the abstraction takes an argument of type <span class="math inline">\(\tau\)</span> and has a return type of the type of <span class="math inline">\(t\)</span>.</p>
<p>For applications, we need to have a term with a function type on the left side, that accepts an argument with the type of the right side:</p>
<p><span class="math display">\[
  \text{T-App: } \frac{
    \begin{array}{c}
      \Gamma \vdash t : \tau \rightarrow \tau&#39; \\
      \Gamma \vdash t&#39; : \tau
    \end{array}
  }{
    \Gamma \vdash t\ t&#39; : \tau&#39;
  }
\]</span></p>
<p>For an addition, we require that the two operands are both integers. The type of the addition is then also an integer:</p>
<p><span class="math display">\[
  \text{T-Add: } \frac{
    \begin{array}{c}
      \Gamma \vdash t : \mathsf{Int} \\
      \Gamma \vdash t&#39; : \mathsf{Int}
    \end{array}
  }{
    \Gamma \vdash t + t&#39; : \mathsf{Int}
  }
\]</span></p>
<p>When typing if-then-else terms, we expect the condition to be a boolean, and the two arms to have the same type:</p>
<p><span class="math display">\[
  \text{T-If: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \mathsf{Bool} \\
      \Gamma \vdash t_2 : \tau \\
      \Gamma \vdash t_3 : \tau
    \end{array}
  }{
    \Gamma \vdash \mathbf{if}\ t_1\ \mathbf{then}\ t_2\ \mathbf{else}\ t_3 : \tau
  }
\]</span></p>
<p>These are all the typing rules we will be working with.</p>
<p>To determine the type of a more complex term, we can combine the typing rules. The type of <span class="math inline">\(\lambda n : \mathsf{Int}. 3 + n\)</span>, for example, is determined as follows:</p>
<p><span class="math display">\[
  \text{T-Abs: } \dfrac{
    \text{T-Add: } \dfrac{
      \text{T-Int: } \dfrac{}{
        \vdash 3 : \mathsf{Int}
      } \quad
      \text{T-Var: } \dfrac{
        n : \mathsf{Int} \in \varnothing, n : \mathsf{Int}
      }{
        \varnothing, n : \mathsf{Int} \vdash n : \mathsf{Int}
      }
    }{
      \varnothing, n : \mathsf{Int} \vdash 3 + n : \mathsf{Int}
    }
  }{
    \vdash \lambda n : \mathsf{Int}. 3 + n : \mathsf{Int} \rightarrow \mathsf{Int}
  }
\]</span></p>
<p>Using these rules, we can implement a type checker in Haskell.</p>
<h3 id="implementation">Implementation</h3>
<p>For the context, we’ll use a <code>Map</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="dt">Context</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Type</span></span></code></pre></div>
<p>The function <code>typeOf</code> will determine the type of a term in a certain context, or will throw a type error. Its type is:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">typeOf ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeError</span> <span class="dt">Type</span></span></code></pre></div>
<details>
<p><summary>The definition of <code>TypeError</code></summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">data</span> <span class="dt">TypeError</span></span></code></pre></div>
<p>The variable was not bound by a lambda abstraction.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a>  <span class="ot">=</span> <span class="dt">UnboundVariable</span> <span class="dt">String</span></span></code></pre></div>
<p>An operand of an addition term was not an integer.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a>  <span class="op">|</span> <span class="dt">AdditionNonInteger</span> <span class="dt">Term</span> <span class="dt">Type</span></span></code></pre></div>
<p>The condition of an if-then-else term is not a boolean.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>  <span class="op">|</span> <span class="dt">NonBooleanCondition</span> <span class="dt">Term</span> <span class="dt">Type</span></span></code></pre></div>
<p>The arms of an if-then-else term have different types.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>  <span class="op">|</span> <span class="dt">ArmsOfDifferentType</span> <span class="dt">Term</span> <span class="dt">Type</span> <span class="dt">Term</span> <span class="dt">Type</span></span></code></pre></div>
<p>A function is applied to an argument of the wrong type.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a>  <span class="op">|</span> <span class="dt">ApplicationWrongArgumentType</span> <span class="dt">Term</span> <span class="dt">Type</span> <span class="dt">Term</span> <span class="dt">Type</span></span></code></pre></div>
<p>A term of a non-function type is the left part of an application.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>  <span class="op">|</span> <span class="dt">ApplicationNotFunction</span> <span class="dt">Term</span> <span class="dt">Type</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</details>
<p>The rules for boolean and integer values are really easy to implement:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>typeOf ctx <span class="dt">TmTrue</span>    <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyBool</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>typeOf ctx <span class="dt">TmFalse</span>   <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyBool</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>typeOf ctx (<span class="dt">TmInt</span> n) <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>We can implement T-Var with a simple lookup:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>typeOf ctx (<span class="dt">TmVar</span> x) <span class="ot">=</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>  <span class="kw">case</span> Map.lookup x ctx <span class="kw">of</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">UnboundVariable</span> x</span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="dt">Just</span> ty <span class="ot">-&gt;</span> <span class="dt">Right</span> ty</span></code></pre></div>
<p>For lambda abstractions, …</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a>typeOf ctx (<span class="dt">TmAbs</span> x ty t) <span class="ot">=</span></span></code></pre></div>
<p>…, we add <code>x</code> with the type <code>ty</code> to the context, and determine the type of <code>t</code> in the new context, …</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>  <span class="kw">let</span> ctx&#39; <span class="ot">=</span> Map.insert x ty ctx</span>
<span id="cb20-2"><a href="#cb20-2"></a>      ty&#39;  <span class="ot">=</span> typeOf ctx&#39; t</span></code></pre></div>
<p>…, and return the function type from <code>ty</code> to <code>ty'</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a>   <span class="kw">in</span> <span class="dt">TyFun</span> ty <span class="op">&lt;$&gt;</span> ty&#39;</span></code></pre></div>
<p>(Note that <code>TyFun ty &lt;$&gt; ty'</code> is the same as:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">case</span> typeOf ctx&#39; ty <span class="kw">of</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>  <span class="dt">Left</span> e    <span class="ot">-&gt;</span> <span class="dt">Left</span> e</span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="dt">Right</span> ty&#39; <span class="ot">-&gt;</span> <span class="dt">Right</span> (<span class="dt">TyFun</span> ty ty&#39;)</span></code></pre></div>
<p>But using the fact that <a href="https://hackage.haskell.org/package/base/docs/Prelude.html#t:Either"><code>Either</code></a> is a <a href="https://hackage.haskell.org/package/base/docs/Prelude.html#t:Functor"><code>Functor</code></a> allows us to use <a href="https://hackage.haskell.org/package/base/docs/Prelude.html#v:fmap"><code>fmap</code></a>, or the infix version <a href="https://hackage.haskell.org/package/base/docs/Prelude.html#v:-60--36--62-"><code>(&lt;$&gt;)</code></a>. This is more succinct that an explicit <code>case</code>-<code>of</code>.</p>
<p>In this <code>case</code>-<code>of</code> expression, <code>ty'</code> has type <code>Type</code>, but above <code>ty' :: Either TypeError Type</code>.)</p>
<p>For type checking applications, we use the fact that <a href="https://hackage.haskell.org/package/base/docs/Prelude.html#t:Either"><code>Either</code></a> is a <a href="https://hackage.haskell.org/package/base/docs/Prelude.html#t:Monad"><code>Monad</code></a>, and use the <a href="https://wiki.haskell.org/Keywords#do"><code>do</code>-notation</a>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>typeOf ctx (<span class="dt">TmApp</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We first determine the types of <code>t1</code> and <code>t2</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb24-2"><a href="#cb24-2"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span></code></pre></div>
<p>The type of <code>t1</code> should be a function type:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a>  <span class="kw">case</span> ty1 <span class="kw">of</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>    <span class="dt">TyFun</span> ty11 ty12 <span class="ot">-&gt;</span></span></code></pre></div>
<p>And the type of <code>t2</code> should be the same as <code>t1</code>’s argument’s type, <code>ty11</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a>      <span class="kw">if</span> ty2 <span class="op">==</span> ty11</span>
<span id="cb26-2"><a href="#cb26-2"></a>        <span class="kw">then</span> <span class="dt">Right</span> ty12</span>
<span id="cb26-3"><a href="#cb26-3"></a>        <span class="kw">else</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ApplicationWrongArgumentType</span> t1 ty1 t2 ty2</span></code></pre></div>
<p>If <code>t1</code> doesn’t have a function type, then we can’t apply it:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ApplicationNotFunction</span> t1 ty1</span></code></pre></div>
<p>For addition, if the two operands are integers, then the result is too:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a>typeOf ctx (<span class="dt">TmAdd</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb28-3"><a href="#cb28-3"></a>  when (ty1 <span class="op">/=</span> <span class="dt">TyInt</span>) <span class="op">$</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">AdditionNonInteger</span> t1 ty1</span>
<span id="cb28-5"><a href="#cb28-5"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span>
<span id="cb28-6"><a href="#cb28-6"></a>  when (ty2 <span class="op">/=</span> <span class="dt">TyInt</span>) <span class="op">$</span></span>
<span id="cb28-7"><a href="#cb28-7"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">AdditionNonInteger</span> t2 ty2</span>
<span id="cb28-8"><a href="#cb28-8"></a>  <span class="dt">Right</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>We can also prevent duplication:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a>typeOf ctx (<span class="dt">TmAdd</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>  check t1</span>
<span id="cb29-3"><a href="#cb29-3"></a>  check t2</span>
<span id="cb29-4"><a href="#cb29-4"></a>  <span class="dt">Right</span> <span class="dt">TyInt</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>  <span class="kw">where</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>    check t <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>      ty <span class="ot">&lt;-</span> typeOf ctx t</span>
<span id="cb29-8"><a href="#cb29-8"></a>      when (ty <span class="op">/=</span> <span class="dt">TyInt</span>) <span class="op">$</span></span>
<span id="cb29-9"><a href="#cb29-9"></a>        <span class="dt">Left</span> <span class="op">$</span> <span class="dt">AdditionNonInteger</span> t ty</span></code></pre></div>
<p>When type checking if-then-else terms, we want the condition to be a boolean, and the arms to be of the same type:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a>typeOf ctx (<span class="dt">TmIf</span> t1 t2 t3) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>  ty1 <span class="ot">&lt;-</span> typeOf ctx t1</span>
<span id="cb30-3"><a href="#cb30-3"></a>  when (ty1 <span class="op">/=</span> <span class="dt">TyBool</span>) <span class="op">$</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">NonBooleanCondition</span> t1 ty1</span>
<span id="cb30-5"><a href="#cb30-5"></a>  ty2 <span class="ot">&lt;-</span> typeOf ctx t2</span>
<span id="cb30-6"><a href="#cb30-6"></a>  ty3 <span class="ot">&lt;-</span> typeOf ctx t3</span>
<span id="cb30-7"><a href="#cb30-7"></a>  when (ty2 <span class="op">/=</span> ty3) <span class="op">$</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>    <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ArmsOfDifferentType</span> t2 ty2 t3 ty3</span>
<span id="cb30-9"><a href="#cb30-9"></a>  <span class="dt">Right</span> ty2</span></code></pre></div>
<p>And that’s it! We’ve now implemented our type checker. Let’s try it!</p>
<h3 id="examples-1">Examples</h3>
<p>Let’s start with some terms we have already defined. The type of the identity function on booleans, <span class="math inline">\(\mathsf{id}_\mathsf{Bool}\)</span>, is:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a>typeOf Map.empty tmIdBool</span>
<span id="cb31-2"><a href="#cb31-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyBool</span>)</span></code></pre></div>
<p>We see that type checking has been successful, since we’ve got a <code>Right</code> value back. And the type is indeed what we were expecting: <span class="math inline">\(\mathsf{Bool} \rightarrow \mathsf{Bool}\)</span>.</p>
<p>Let’s also define the identity functions on boolean-to-integer functions:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">tmIdBoolToInt ::</span> <span class="dt">Term</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>tmIdBoolToInt <span class="ot">=</span> <span class="dt">TmAbs</span> <span class="st">&quot;f&quot;</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>) (<span class="dt">TmVar</span> <span class="st">&quot;f&quot;</span>)</span></code></pre></div>
<p>We expect its type to be <span class="math inline">\((\mathsf{Bool} \rightarrow \mathsf{Int}) \rightarrow (\mathsf{Bool} \rightarrow \mathsf{Int})\)</span>, and indeed:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a>typeOf Map.empty tmIdBoolToInt</span>
<span id="cb33-2"><a href="#cb33-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyFun</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>) (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>))</span></code></pre></div>
<p>The type of <span class="math inline">\(\mathsf{not}\)</span> should be <span class="math inline">\(\mathsf{Bool} \rightarrow \mathsf{Bool}\)</span>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a>typeOf Map.empty tmNot</span>
<span id="cb34-2"><a href="#cb34-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyBool</span>)</span></code></pre></div>
<p>And the type of <span class="math inline">\(\mathsf{add}\)</span> should be <span class="math inline">\(\mathsf{Int} \rightarrow \mathsf{Int} \rightarrow \mathsf{Int}\)</span>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a>typeOf Map.empty tmAdd</span>
<span id="cb35-2"><a href="#cb35-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyFun</span> <span class="dt">TyInt</span> (<span class="dt">TyFun</span> <span class="dt">TyInt</span> <span class="dt">TyInt</span>))</span></code></pre></div>
<p>So far, so good. Let’s also take a look at terms that should be rejected.</p>
<p>We expect our type checker to reject the term <span class="math inline">\(\mathsf{True} + 1\)</span>, since we can’t add booleans and integers:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a>typeOf Map.empty (<span class="dt">TmAdd</span> <span class="dt">TmTrue</span> (<span class="dt">TmInt</span> <span class="dv">1</span>))</span>
<span id="cb36-2"><a href="#cb36-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">AdditionNonInteger</span> <span class="dt">TmTrue</span> <span class="dt">TyBool</span>)</span></code></pre></div>
<p>Hurray, one mistake prevented!</p>
<p>We can’t refer to variables that are not bound:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a>typeOf Map.empty (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)</span>
<span id="cb37-2"><a href="#cb37-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">UnboundVariable</span> <span class="st">&quot;x&quot;</span>)</span></code></pre></div>
<p>But if the variable is defined in the context, that should be no problem:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a>typeOf (Map.fromList [(<span class="st">&quot;x&quot;</span>, <span class="dt">TyInt</span>)]) (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)</span>
<span id="cb38-2"><a href="#cb38-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>We should also reject <span class="math inline">\(\mathsf{not}\ 14\)</span>, because <span class="math inline">\(\mathsf{not}\)</span> expects a boolean parameter:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a>typeOf Map.empty (<span class="dt">TmApp</span> tmNot (<span class="dt">TmInt</span> <span class="dv">14</span>))</span>
<span id="cb39-2"><a href="#cb39-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>      (<span class="dt">ApplicationWrongArgumentType</span></span>
<span id="cb39-4"><a href="#cb39-4"></a>        (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> <span class="dt">TyBool</span> (<span class="dt">TmIf</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>) <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>))</span>
<span id="cb39-5"><a href="#cb39-5"></a>        (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyBool</span>)</span>
<span id="cb39-6"><a href="#cb39-6"></a>        (<span class="dt">TmInt</span> <span class="dv">14</span>)</span>
<span id="cb39-7"><a href="#cb39-7"></a>        <span class="dt">TyInt</span>)</span></code></pre></div>
<p>It would be nice to display these errors more user-friendly, but that’s left as an exercise to the reader!</p>
<p>Let’s try applying to a non-function value:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a>typeOf Map.empty (<span class="dt">TmApp</span> <span class="dt">TmFalse</span> (<span class="dt">TmInt</span> <span class="dv">21</span>))</span>
<span id="cb40-2"><a href="#cb40-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">ApplicationNotFunction</span> <span class="dt">TmFalse</span> <span class="dt">TyBool</span>)</span></code></pre></div>
<p>And if-then-else terms with a non-boolean condition:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a>typeOf Map.empty (<span class="dt">TmIf</span> (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> <span class="dt">TyBool</span> (<span class="dt">TmInt</span> <span class="dv">0</span>)) (<span class="dt">TmInt</span> <span class="dv">3</span>) (<span class="dt">TmInt</span> <span class="dv">4</span>))</span>
<span id="cb41-2"><a href="#cb41-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>       (<span class="dt">NonBooleanCondition</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>         (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> <span class="dt">TyBool</span> (<span class="dt">TmInt</span> <span class="dv">0</span>))</span>
<span id="cb41-5"><a href="#cb41-5"></a>         (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>))</span></code></pre></div>
<p>Or with non-matching arms:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a>typeOf Map.empty (<span class="dt">TmIf</span> <span class="dt">TmTrue</span> (<span class="dt">TmInt</span> <span class="dv">10</span>) <span class="dt">TmFalse</span>)</span>
<span id="cb42-2"><a href="#cb42-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">ArmsOfDifferentType</span> (<span class="dt">TmInt</span> <span class="dv">10</span>) <span class="dt">TyInt</span> <span class="dt">TmFalse</span> <span class="dt">TyBool</span>)</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>We’ve written a type checker for the simply typed lambda calculus!</p>
<p>If you want to a play a bit more with this type checker, you might want to do one of the following exercises, which I highly suggest:</p>
<ol type="1">
<li>Add other binary operators on integers, such as subtraction, multiplication, etc. Extend the abstract syntax, write the typing rules for these terms and extend the type checker to follow these rules.</li>
<li>Add support for another simple type, such as characters or strings. Extend the abstract syntax, write the typing rules and extend the type checker. Also add some computation constructs that interact with these values: for characters for example, you might want to add functions like Haskell’s <a href="https://hackage.haskell.org/package/base/docs/Data-Char.html#v:ord"><code>ord :: Char -&gt; Int</code></a> and <a href="https://hackage.haskell.org/package/base/docs/Data-Char.html#v:chr"><code>chr :: Int -&gt; Char</code></a>.</li>
<li>Write an evaluator for the STLC.</li>
<li>Write a parser for STLC terms. You might want to take a look at <a href="https://hackage.haskell.org/package/parsec">Parsec</a>, or find an introduction to <em>parser combinators</em>.</li>
<li>Rewrite the type checker using <a href="https://hackage.haskell.org/package/mtl">monad transformers</a>. The type checker can be written in the <code>ReaderT Context (Except TypeError)</code> monad. <a href="http://learnyouahaskell.com"><em>Learn You a Haskell for Great Good</em></a> has an <a href="http://learnyouahaskell.com/for-a-few-monads-more">introduction to monad transformers</a>.</li>
</ol>
<p>In the next post, I’ll describe how we can add more support for abstraction to the simply typed lambda calculus, and we’ll take a look at the <em>polymorphic lambda calculus</em>.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Using integers as variables is actually a well-known technique. It is useful for writing an evaluator of the lambda calculus, because it is a lot easier to define substitution that way. If you want to know more, read about <a href="https://en.wikipedia.org/wiki/De_Bruijn_index"><em>De Bruijn-indices</em></a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Instead of having support for functions with multiple parameters, we choose to write functions that return other functions. A function that adds its two integer parameters, for example, is written like <span class="math inline">\(\lambda a : \mathsf{Int}. \lambda b : \mathsf{Int}. a + b\)</span>. This is called <a href="https://en.wikipedia.org/wiki/Currying">Currying</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Introduction to Type Systems</title>
    <link href="https://splintah.github.io/posts/2020-05-23-Introduction-to-type-systems.html" />
    <id>https://splintah.github.io/posts/2020-05-23-Introduction-to-type-systems.html</id>
    <published>2020-05-23T00:00:00Z</published>
    <updated>2020-05-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <h1>Introduction to Type Systems</h1>
  <section class="header">
    23 May 2020
    
  </section>
  
    <section class="series-info">
      This post is part 1 of 4 of the series <a href="/series/Introduction%20to%20Type%20Systems.html">Introduction to Type Systems</a>.
    </section>
  
  <section>
    <h2 id="introduction">Introduction</h2>
<p>In this series, I will explain various type systems and their implementations in Haskell. The aim for this series is to be an approachable way to learn about type systems. I will try to cover both the theoretical aspects, such as formal (mathematical) notation, and the practical aspects, consisting of a Haskell implementation. After reading this series, you should have an understanding of the basics of type systems.</p>
<h2 id="read-the-series">Read the series</h2>
<p>You can find a list of the series’ posts <a href="/series/Introduction%20to%20Type%20Systems.html">here</a>.</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>, Benjamin C. Pierce.</li>
<li><a href="https://softwarefoundations.cis.upenn.edu/plf-current/index.html"><em>Software Foundations, volume 2: Programming Language Foundations</em></a>, Benjamin C. Pierce <em>et al.</em></li>
<li><a href="https://plfa.github.io/"><em>Programming Language Foundations in Agda</em></a>, Philip Wadler, Wen Kokke and Jeremy Siek.</li>
</ul>
  </section>
</article>
]]></summary>
</entry>
<entry>
    <title>Using Emacs in a local Nix environment</title>
    <link href="https://splintah.github.io/posts/2020-04-13-emacs-local-nix-environment.html" />
    <id>https://splintah.github.io/posts/2020-04-13-emacs-local-nix-environment.html</id>
    <published>2020-04-13T00:00:00Z</published>
    <updated>2020-04-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <h1>Using Emacs in a local Nix environment</h1>
  <section class="header">
    13 April 2020
    
  </section>
  
  <section>
    <p>In this blog post, I explain how to use Emacs in a local Nix environment for all modes, without needing mode-specific configuration.</p>
<hr />
<p>Recently, I was trying to get <a href="https://github.com/haskell/haskell-mode"><code>haskell-mode</code></a> in Emacs to work inside a (local) Nix environment, à la <code>nix-shell</code>. I use Nix to manage my Haskell dependencies<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Those dependencies aren’t installed globally (or rather, aren’t in my <code>$PATH</code>), and I don’t want them to be installed by Cabal, so building the project and running GHCI should happen inside a Nix environment.</p>
<p>With <code>haskell-mode</code>, you can run the function <code>haskell-process-load-file</code> to run GHCI inside Emacs. If you set <code>haskell-process-type</code> to <code>'cabal-repl</code> (or <code>'cabal-new-repl</code>), GHCI will use Cabal to manage dependencies, but it will run <code>cabal</code> in your <code>$PATH</code>, or the program specified in <code>haskell-process-path-cabal</code>.</p>
<h2 id="wrapper-script">Wrapper script</h2>
<p>So I created a script with the following contents:</p>
<div class="sourceCode" id="cb1" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="va">args=$@</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ex">nix-shell</span> --run <span class="st">&quot;cabal </span><span class="va">$args</span><span class="st">&quot;</span></span></code></pre></div>
<p>…, and set <code>haskell-process-path-cabal</code> to the path to the script.</p>
<p>This works quite well, but isn’t very elegant.</p>
<h2 id="wrapper-function">Wrapper function</h2>
<p>Then I discovered the <code>haskell-mode</code> option <code>haskell-process-wrapper-function</code>, which ‘wraps or transforms Haskell process commands (…)’, according to the documentation. The documentation even contains an example value which makes the process commands run inside a <code>nix-shell</code> (simplified a bit here):</p>
<div class="sourceCode" id="cb2" data-org-language="emacs-lisp"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1"></a>(<span class="kw">setq</span> haskell-process-wrapper-function</span>
<span id="cb2-2"><a href="#cb2-2"></a>      (<span class="kw">lambda</span> (argv)</span>
<span id="cb2-3"><a href="#cb2-3"></a>        (<span class="kw">list</span> <span class="st">&quot;nix-shell&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>              <span class="st">&quot;-I&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>              <span class="st">&quot;.&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>              <span class="st">&quot;--command&quot;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>              (mapconcat &#39;identity argv <span class="st">&quot; &quot;</span>))))</span></code></pre></div>
<p>This is works well, and is a lot more elegant than the script above. But it only works for <code>haskell-mode</code>: when I want to run Python with packages managed by Nix inside Emacs, I’ll have to search <code>python-mode</code> for an option similar to <code>haskell-process-wrapper-function</code>. And when I want to use yet another language, …</p>
<h2 id="lorri-and-direnv">lorri and direnv</h2>
<p>So I tried to find a general solution, and found <a href="https://github.com/target/lorri">lorri</a>. lorri integrates <a href="https://direnv.net">direnv</a> with Nix. With lorri, you don’t need <code>nix-shell</code> anymore, since direnv automatically changes your path, and lorri automatically builds your shell environment. (See the <a href="https://github.com/target/lorri#demo">lorri demonstration</a>.)</p>
<p>The direnv home page explains how to install a direnv hook into your shell, but you can also add direnv to Emacs: the <a href="https://github.com/wbolster/emacs-direnv">emacs-direnv</a> package adds direnv support. It’s as simple as adding the following to your Emacs configuration (if you use <a href="https://github.com/jwiegley/use-package"><code>use-package</code></a>):</p>
<div class="sourceCode" id="cb3" data-org-language="emacs-lisp"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1"></a>(<span class="kw">use-package</span> direnv</span>
<span id="cb3-2"><a href="#cb3-2"></a>  :config</span>
<span id="cb3-3"><a href="#cb3-3"></a>  (direnv-mode))</span></code></pre></div>
<p>If you now visit a file in a directory where lorri is initialised, your environment variables will be updated, and you can run all sorts of processes (<code>haskell-mode</code>’s GHCI, <code>python-mode</code>’s REPL, <code>eshell</code>, etc.) inside a Nix environment.</p>
<p>direnv changes the environment variables (such as <code>$PATH</code>) that were generated by lorri in a local directory. Because your <code>$PATH</code> is changed when you visit a file in that directory, there is no need for any mode-specific Emacs configuration.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Read how to do this in the <a href="https://nixos.org/nixpkgs/manual/#how-to-create-nix-builds-for-your-own-private-haskell-packages">Nixpkgs manual</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </section>
</article>
]]></summary>
</entry>

</feed>
