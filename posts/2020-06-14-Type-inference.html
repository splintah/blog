<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Type inference - Splinter Suidman</title>
    <link rel="stylesheet" href="../css/default.css" />
  </head>
  <body>
    <header>
      <div class="logo">
        <a href="../">Splinter Suidman</a>
      </div>
      <nav>
        <a href="../">Home</a>
        <a href="../about.html">About</a>
        <a href="../feeds.html">Feeds</a>
      </nav>
    </header>

    <main role="main">
      <article>
  <h1>Type inference</h1>
  <section class="header">
    14 June 2020
    
  </section>
  
    <section class="series-info">
      This post is part 4 of 4 of the series <a href="../series/Introduction%20to%20Type%20Systems.html">Introduction to Type Systems</a>.
    </section>
  
  <section>
    <p>In the previous post, we have added polymorphism to the simply typed lambda calculus and implemented a type checker for the polymorphic lambda calculus. In this post, we’ll explore <em>type inference</em> or <em>reconstruction</em>.</p>
<details>
<p><summary>Imports etc.</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> <span class="dt">Inference</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span>           <span class="dt">Control.Monad</span>        (when)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Except</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span>           <span class="dt">Control.Monad.RWS</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span>           <span class="dt">Data.Bifunctor</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>      <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>      (<span class="dt">Map</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>             <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">import</span>           <span class="dt">Data.Set</span>             (<span class="dt">Set</span>)</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">import</span>           <span class="dt">Test.QuickCheck</span></span></code></pre></div>
</details>
<h2 id="motivation">Motivation</h2>
<p>In the polymorphic lambda calculus, we can write polymorphic (generic) functions that work on all types, using <em>parametric polymorphism</em>. This is a major benefit over the simply typed lambda calculus, because it reduces duplication: for example, we no longer have to write an identity function for every type that we might need one for, but can write exactly one identity function that works on all types.</p>
<p>But, as you might have noticed, it is quite some work to use such polymorphic functions. Where we could define <span class="math inline">\(\mathsf{const}\)</span> as <span class="math inline">\(\lambda x. \lambda y. x\)</span> and use it like <span class="math inline">\(\mathsf{const}\ (\lambda x. x)\ (\lambda f. \lambda x. f\ x)\)</span> in the untyped lambda calculus, in the polymorphic lambda calculus we have to type <span class="math inline">\(\mathsf{const} = \Lambda X. \Lambda Y. \lambda x : X. \lambda y : Y. x\)</span> and use it like the following for the same example: <span class="math display">\[
\begin{align*}
  \mathsf{const}\ &amp; (\forall X. X \rightarrow X) \\
    &amp; (\forall A. \forall B. (A \rightarrow B) \rightarrow A \rightarrow B) \\
    &amp; (\Lambda X. \lambda x : X. x) \\
    &amp; (\Lambda A. \Lambda B. \lambda f : A \rightarrow B. \lambda x : A. f\ x)
\end{align*}
\]</span></p>
<p>We have to do a whole lot of typing to make the type checker happy. Wouldn’t it be nice if we could write our terms like in the untyped lambda calculus, with the same static safety as in the polymorphic lambda calculus? It turns out that we can actually implement a type checker that <em>infers</em> or <em>reconstructs</em> the types from a fully untyped program. This technique is called <em>type inference</em> or <em>type reconstruction</em>, and the corresponding type system is called the <em>Hindley-Milner type system</em>.</p>
<h2 id="syntax">Syntax</h2>
<p>To write programs without any type information, we remove all types from the syntax of terms. So no more type abstractions, type applications or lambda abstractions with explicit types (e.g., we’ll write <span class="math inline">\(\lambda x. x\)</span> instead of <span class="math inline">\(\lambda x : X. x\)</span>).</p>
<p>The AST looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">Term</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="ot">=</span> <span class="dt">TmTrue</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="co">-- ^ True value</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="op">|</span> <span class="dt">TmFalse</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">-- ^ False value</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="op">|</span> <span class="dt">TmInt</span> <span class="dt">Integer</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="co">-- ^ Integer value</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="op">|</span> <span class="dt">TmVar</span> <span class="dt">String</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="co">-- ^ Variable</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="op">|</span> <span class="dt">TmAbs</span> <span class="dt">String</span> <span class="dt">Term</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="co">-- ^ Lambda abstraction</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="op">|</span> <span class="dt">TmApp</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span class="co">-- ^ Application</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span class="op">|</span> <span class="dt">TmAdd</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>    <span class="co">-- ^ Addition</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="op">|</span> <span class="dt">TmIf</span> <span class="dt">Term</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="co">-- ^ If-then-else conditional</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>  <span class="op">|</span> <span class="dt">TmLet</span> <span class="dt">String</span> <span class="dt">Term</span> <span class="dt">Term</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="co">-- ^ Let-in</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>You might notice that this is just the syntax of the untyped lambda calculus (<code>TmVar</code>, <code>TmAbs</code>, <code>TmApp</code>) with the syntax constructs of the simply typed lambda calculus (<code>TmTrue</code>, <code>TmFalse</code>, <code>TmInt</code>, <code>TmAdd</code>, <code>TmIf</code>), plus the addition of the <code>TmLet</code> constructor, which is used for terms of the form <span class="math inline">\(\mathbf{let}\ x = t\ \mathbf{in}\ t'\)</span>. The addition of let-in terms is not strictly necessary, but it is if we actually want to use polymorphism. (This will be discussed later.)</p>
<p>For the syntax of types, we do have to make a substantial change, though. We must restrict our usage of polymorphism: we can only use <span class="math inline">\(\forall\)</span>’s at the top level; no more <span class="math inline">\((\forall A. A \rightarrow A) \rightarrow (\forall B. B \rightarrow B)\)</span>, for example. We have to do this, because type inference for the polymorphic lambda calculus as we saw it in the previous post is <a href="https://en.wikipedia.org/wiki/Undecidable_problem">undecidable</a>. We will therefore split our type syntax into two: <em>monotypes</em> and <em>polytypes</em> (or <em>type schemes</em>).</p>
<p>The syntax for <em>polytypes</em> (for which we’ll write <span class="math inline">\(\sigma\)</span>) is very simple:</p>
<p><span class="math display">\[
\begin{align*}
  \sigma ::=\ &amp; \forall \vec{X}. \tau &amp; \text{(polytype)} \\
\end{align*}
\]</span></p>
<p>Here <span class="math inline">\(\tau\)</span> is a monotype, and <span class="math inline">\(\vec{X}\)</span> is a (possibly empty) list of type variables.</p>
<p>In Haskell, this is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Polytype</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="ot">=</span> <span class="dt">TyForall</span> [<span class="dt">String</span>] <span class="dt">Type</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>(We’ll use just <code>Type</code> to refer to monotypes.)</p>
<p>The syntax for monotypes looks like this:</p>
<p><span class="math display">\[
\begin{align*}
  \tau ::=\ &amp; X &amp; \text{(type variable)} \\
      \mid\ &amp; \tau \rightarrow \tau' &amp; \text{(function type)} \\
      \mid\ &amp; \mathsf{Bool} &amp; \text{(boolean type)} \\
      \mid\ &amp; \mathsf{Int} &amp; \text{(integer type)}
\end{align*}
\]</span></p>
<p>Or in Haskell:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">data</span> <span class="dt">Type</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="ot">=</span> <span class="dt">TyVar</span> <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">-- ^ Type variable</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="op">|</span> <span class="dt">TyFun</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="co">-- ^ Function type</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="op">|</span> <span class="dt">TyBool</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="co">-- ^ Boolean type</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>  <span class="op">|</span> <span class="dt">TyInt</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="co">-- ^ Integer type</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>The type for the identity function (which we now write as just <span class="math inline">\(\lambda x. x\)</span>), <span class="math inline">\(\forall X. X \rightarrow X\)</span>, is written in Haskell as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">tmId ::</span> <span class="dt">Term</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>tmId <span class="ot">=</span> <span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ot">tyId ::</span> <span class="dt">Polytype</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>tyId <span class="ot">=</span> <span class="dt">TyForall</span> [<span class="st">&quot;X&quot;</span>] <span class="op">$</span> <span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)</span></code></pre></div>
<p>And <span class="math inline">\(\mathsf{const}\)</span>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">tmConst ::</span> <span class="dt">Term</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>tmConst <span class="ot">=</span> <span class="dt">TmAbs</span> <span class="st">&quot;a&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;b&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;a&quot;</span>))</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">tyConst ::</span> <span class="dt">Polytype</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>tyConst <span class="ot">=</span> <span class="dt">TyForall</span> [<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>] <span class="op">$</span> <span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>))</span></code></pre></div>
<h2 id="type-checking">Type checking</h2>
<p>Type inference is quite a bit harder than type checking the simply typed lambda calculus or the polymorphic lambda calculus <em>with</em> explicit type annotations. We will use a constraint-based type inference algorithm, based on <a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>, Benjamin C. Pierce, Chapter 22.3. I have found this to be the most intuitive approach. I will deviate a bit from Pierce’s approach, though, to make the rules somewhat easier to read.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>For type inference, we will use a different typing relation than the one we used for the simply typed and the polymorphic (but explicitly typed) lambda calculus. Before, we used the relation <span class="math inline">\(\Gamma \vdash t : \tau\)</span>, which could be read something like: <em><span class="math inline">\(\Gamma\)</span> entails that <span class="math inline">\(t\)</span> has type <span class="math inline">\(\tau\)</span></em>. Now, we will use the typing relation written as follows: <span class="math inline">\(\Gamma \vdash t : \tau \mid C\)</span>. This can be read as: <em><span class="math inline">\(\Gamma\)</span> entails that <span class="math inline">\(t\)</span> has type <span class="math inline">\(\tau\)</span> if the constraints of <span class="math inline">\(C\)</span> are satisfied</em>. Our type inference program will generate a set of <em>constraints</em>, which ought to be <em>satisfied</em> for the type checker to succeed. (Another change is the context <span class="math inline">\(\Gamma\)</span>, which will now contain pairs <span class="math inline">\(x : \sigma\)</span> of variables and <em>polytypes</em> instead of pairs <span class="math inline">\(x : \tau\)</span> of variables and monotypes.)</p>
<h3 id="constraint-solving">Constraint solving</h3>
<p>A <em>constraint</em> <span class="math inline">\(\tau \sim \tau'\)</span> states that <span class="math inline">\(\tau\)</span> and <span class="math inline">\(\tau'\)</span> should be <em>unified</em>. The constraint <span class="math inline">\(A \sim B \rightarrow \mathsf{Int}\)</span>, for example, asserts that the type variable <span class="math inline">\(A\)</span> should be equal to the type <span class="math inline">\(B \rightarrow \mathsf{Int}\)</span>. A <em>constraint set</em> <span class="math inline">\(C\)</span> is a set (or a list) of constraints. We want to write a a function that <em>unifies</em> a constraint set. This unification function will generate a substitution <span class="math inline">\(\mathcal{S}\)</span>, such that the substitution <em>unifies</em> all constraints in <span class="math inline">\(C\)</span>: for all constraints <span class="math inline">\(\tau \sim \tau'\)</span>, <span class="math inline">\(\mathcal{S} \tau\)</span> (the substitution <span class="math inline">\(\mathcal{S}\)</span> applied to the type <span class="math inline">\(\tau\)</span>) should be equal to <span class="math inline">\(\mathcal{S} \tau'\)</span>.</p>
<p>In Haskell, we will create the following <code>Constraint</code> type, with the infix constructor <code>(:~:)</code> that corresponds to the <span class="math inline">\(\sim\)</span> in a constraint:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">data</span> <span class="dt">Constraint</span> <span class="ot">=</span> <span class="dt">Type</span> <span class="op">:~:</span> <span class="dt">Type</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>For substitutions, we use a map:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="dt">Subst</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Type</span></span></code></pre></div>
<p>The <code>substType</code> function will apply a substitution to a type. Applying substitutions to monotypes (i.e., without <span class="math inline">\(\forall\)</span>s) is quite easy, because we don’t have to worry about renaming.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">substType ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>substType s <span class="dt">TyBool</span> <span class="ot">=</span> <span class="dt">TyBool</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>substType s <span class="dt">TyInt</span>  <span class="ot">=</span> <span class="dt">TyInt</span></span></code></pre></div>
<p>When we come across a type variable, we replace it by the corresponding type in the substitution, or keep it when the variable does not occur in the substitution:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>substType s (<span class="dt">TyVar</span> x) <span class="ot">=</span> Map.findWithDefault (<span class="dt">TyVar</span> x) x s</span></code></pre></div>
<p>For function types, we just apply the substitution recursively:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a>substType s (<span class="dt">TyFun</span> t1 t2) <span class="ot">=</span> <span class="dt">TyFun</span> (substType s t1) (substType s t2)</span></code></pre></div>
<p>With the <code>substType</code> function, we can very easily apply a substitution to a constraint, by applying the substitution to the left-hand side and the right-hand side:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">substConstraint ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>substConstraint s (t1 <span class="op">:~:</span> t2) <span class="ot">=</span> substType s t1 <span class="op">:~:</span> substType s t2</span></code></pre></div>
<p>We can also apply a substitution to a polytype <span class="math inline">\(\forall \vec{X}. \tau\)</span>, which applies the substitution to <span class="math inline">\(\tau\)</span>, with all elements from the substitution with a key from <span class="math inline">\(\vec{X}\)</span> removed:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">substPolytype ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Polytype</span> <span class="ot">-&gt;</span> <span class="dt">Polytype</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>substPolytype s (<span class="dt">TyForall</span> xs ty) <span class="ot">=</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="kw">let</span> s' <span class="ot">=</span> <span class="fu">foldr</span> Map.delete s xs</span>
<span id="cb13-4"><a href="#cb13-4"></a>   <span class="kw">in</span> <span class="dt">TyForall</span> xs (substType s' ty)</span></code></pre></div>
<p>As we’ve seen in the previous post, substitution is generally quite hard for types which bind type variables, because the programmer might use the same type variable twice in different contexts, causing them to clash in some cases. Luckily, this won’t be a problem here, since the programmer doesn’t write any type variables. Instead, all type variables that we use are generated by the inference algorithm, which makes sure they are all unique (or <em>fresh</em>). This will be explained later.</p>
<p>We also need to be able to compose two substitutions. In mathematical notation, we write <span class="math inline">\(\mathcal{S}_1 \circ \mathcal{S}_2\)</span> for the composition of <span class="math inline">\(\mathcal{S}_1\)</span> and <span class="math inline">\(\mathcal{S}_2\)</span>, where <span class="math inline">\(\mathcal{S}_2\)</span> is applied first. We want <span class="math inline">\((\mathcal{S}_1 \circ \mathcal{S}_2)\tau\)</span> for any type <span class="math inline">\(\tau\)</span> to be equal to <span class="math inline">\(\mathcal{S}_1(\mathcal{S}_2\tau)\)</span>. We first apply <span class="math inline">\(\mathcal{S}_1\)</span> to the codomain (that is, the <em>values</em>, not the keys, of the <code>Map</code>) of <span class="math inline">\(\mathcal{S}_2\)</span>, and then return the union of the result and <span class="math inline">\(\mathcal{S}_1\)</span>, where values of the first substitution are preferred:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="ot">compose ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>compose s1 s2 <span class="ot">=</span> <span class="fu">fmap</span> (substType s1) s2 <span class="ot">`Map.union`</span> s1</span></code></pre></div>
<p>Then, we can write the unification function for a single constraint:</p>
<details>
<p><summary>The definition of <code>UnifyError</code></summary></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">data</span> <span class="dt">UnifyError</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>  <span class="ot">=</span> <span class="dt">CannotUnify</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="op">|</span> <span class="dt">InfiniteType</span> <span class="dt">String</span> <span class="dt">Type</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</details>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">unify ::</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnifyError</span> <span class="dt">Subst</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>unify c <span class="ot">=</span> <span class="kw">case</span> c <span class="kw">of</span></span></code></pre></div>
<p>To unify two equal simple types, we don’t have to apply any substitution, so we’ll just return an empty substitution:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>  <span class="dt">TyBool</span> <span class="op">:~:</span> <span class="dt">TyBool</span> <span class="ot">-&gt;</span> <span class="dt">Right</span> Map.empty</span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="dt">TyInt</span>  <span class="op">:~:</span> <span class="dt">TyInt</span>  <span class="ot">-&gt;</span> <span class="dt">Right</span> Map.empty</span></code></pre></div>
<p>To unify two function types, we just need to unify both parameter types and both target types. We do this using the <code>solve</code> function, which can unify a list of constraints. We’ll define <code>solve</code> later.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>  <span class="dt">TyFun</span> t1 t2 <span class="op">:~:</span> <span class="dt">TyFun</span> t1' t2' <span class="ot">-&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>    solve [ t1 <span class="op">:~:</span> t1'</span>
<span id="cb18-3"><a href="#cb18-3"></a>          , t2 <span class="op">:~:</span> t2' ]</span></code></pre></div>
<p>To unify a type variable with another type, we use the <code>bind</code> helper function, which we’ll also define later.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a>  t1      <span class="op">:~:</span> <span class="dt">TyVar</span> x <span class="ot">-&gt;</span> bind x t1</span>
<span id="cb19-2"><a href="#cb19-2"></a>  <span class="dt">TyVar</span> x <span class="op">:~:</span> t2      <span class="ot">-&gt;</span> bind x t2</span></code></pre></div>
<p>Any other constraint is unsolvable, so we’ll just throw an error:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>  t1 <span class="op">:~:</span> t2 <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">CannotUnify</span> t1 t2</span></code></pre></div>
<p>For unifying a type variable with another type, we use the <code>bind</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">bind ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnifyError</span> <span class="dt">Subst</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>bind x t</span></code></pre></div>
<p>When <code>t</code> is the same as the type variable <code>x</code>, we don’t have to do any substituting:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a>  <span class="op">|</span> t <span class="op">==</span> <span class="dt">TyVar</span> x   <span class="ot">=</span> <span class="dt">Right</span> Map.empty</span></code></pre></div>
<p>When the type variable <code>x</code> occurs freely in <code>t</code> (and it is not <code>x</code> itself, which we have checked in the previous case), we cannot unify them, since that would require infinite types. The constraint <span class="math inline">\(X \sim X \rightarrow X\)</span>, for example, has no solution:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>  <span class="op">|</span> x <span class="ot">`occursIn`</span> t <span class="ot">=</span> <span class="dt">Left</span> <span class="op">$</span> <span class="dt">InfiniteType</span> x t</span></code></pre></div>
<p>Otherwise, we can just return the substitution which substitutes <code>x</code> by <code>t</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="dt">Right</span> <span class="op">$</span> Map.fromList [(x, t)]</span></code></pre></div>
<p>The <code>occursIn</code> function is very straight-forward:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="ot">occursIn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>x <span class="ot">`occursIn`</span> t <span class="ot">=</span> <span class="kw">case</span> t <span class="kw">of</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="dt">TyBool</span>      <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="dt">TyInt</span>       <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>  <span class="dt">TyFun</span> t1 t2 <span class="ot">-&gt;</span> x <span class="ot">`occursIn`</span> t1 <span class="op">||</span> x <span class="ot">`occursIn`</span> t2</span>
<span id="cb25-6"><a href="#cb25-6"></a>  <span class="dt">TyVar</span> y     <span class="ot">-&gt;</span> x <span class="op">==</span> y</span></code></pre></div>
<p>Finally, we can solve a list of constraints:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="ot">solve ::</span> [<span class="dt">Constraint</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnifyError</span> <span class="dt">Subst</span></span></code></pre></div>
<p>Solving an empty list of constraints just corresponds to doing nothing:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a>solve [] <span class="ot">=</span> <span class="dt">Right</span> Map.empty</span></code></pre></div>
<p>To solve a non-empty list of constraints, we first unify the constraint <code>c</code>, which gives us the substitution <code>s1</code>. We apply this substitution to the rest of the constraints and solve the result, giving us the substitution <code>s2</code>, and then return the composition of <code>s2</code> and <code>s1</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a>solve (c<span class="op">:</span>cs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>  s1 <span class="ot">&lt;-</span> unify c</span>
<span id="cb28-3"><a href="#cb28-3"></a>  s2 <span class="ot">&lt;-</span> solve <span class="op">$</span> <span class="fu">fmap</span> (substConstraint s1) cs</span>
<span id="cb28-4"><a href="#cb28-4"></a>  <span class="dt">Right</span> (s2 <span class="ot">`compose`</span> s1)</span></code></pre></div>
<p>Some examples:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a>solve [<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span> <span class="op">:~:</span> <span class="dt">TyInt</span>]</span>
<span id="cb29-2"><a href="#cb29-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (fromList [(<span class="st">&quot;X&quot;</span>,<span class="dt">TyInt</span>)])</span>
<span id="cb29-3"><a href="#cb29-3"></a></span>
<span id="cb29-4"><a href="#cb29-4"></a>solve [<span class="dt">TyInt</span> <span class="op">:~:</span> <span class="dt">TyBool</span>]</span>
<span id="cb29-5"><a href="#cb29-5"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">CannotUnify</span> <span class="dt">TyInt</span> <span class="dt">TyBool</span>)</span>
<span id="cb29-6"><a href="#cb29-6"></a></span>
<span id="cb29-7"><a href="#cb29-7"></a>solve [<span class="dt">TyInt</span> <span class="op">:~:</span> <span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>, <span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span> <span class="op">:~:</span> <span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyBool</span>]</span>
<span id="cb29-8"><a href="#cb29-8"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">CannotUnify</span> <span class="dt">TyInt</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyBool</span>))</span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a>solve [<span class="dt">TyInt</span> <span class="op">:~:</span> <span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>, <span class="dt">TyVar</span> <span class="st">&quot;Y&quot;</span> <span class="op">:~:</span> <span class="dt">TyBool</span>]</span>
<span id="cb29-11"><a href="#cb29-11"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (fromList [(<span class="st">&quot;X&quot;</span>,<span class="dt">TyInt</span>),(<span class="st">&quot;Y&quot;</span>,<span class="dt">TyBool</span>)])</span>
<span id="cb29-12"><a href="#cb29-12"></a></span>
<span id="cb29-13"><a href="#cb29-13"></a>solve [<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span> <span class="op">:~:</span> <span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)]</span>
<span id="cb29-14"><a href="#cb29-14"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">InfiniteType</span> <span class="st">&quot;X&quot;</span> (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;X&quot;</span>)))</span></code></pre></div>
<p>We can also test whether <code>solve</code> has the desired behaviour, namely that the resulting substitution unifies the constraints. To do this, we’ll use the <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library:</p>
<details>
<p><summary>Testing <code>solve</code></summary></p>
<p>We will first need an instance of <a href="https://hackage.haskell.org/package/QuickCheck/docs/Test-QuickCheck.html#t:Arbitrary"><code>Arbitrary</code></a> for <code>Type</code> and <code>Constraint</code>. The instance for <code>Type</code> is adapted from the <a href="https://github.com/nick8325/quickcheck/blob/master/examples/Lambda.hs">lambda calculus example</a>. The frequency for <code>TyInt</code> and <code>TyBool</code> are relatively low, because a frequent occurrence of these simple types in the generated arbitrary types results in a lot of failed calls to <code>solve</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>  arbitrary <span class="ot">=</span> sized arbType</span>
<span id="cb30-3"><a href="#cb30-3"></a>   <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>    arbType n <span class="ot">=</span> frequency <span class="op">$</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>      [ (<span class="dv">10</span>, <span class="dt">TyVar</span> <span class="op">&lt;$&gt;</span> arbVar)</span>
<span id="cb30-6"><a href="#cb30-6"></a>      , (<span class="dv">1</span>, <span class="fu">pure</span> <span class="dt">TyInt</span>)</span>
<span id="cb30-7"><a href="#cb30-7"></a>      , (<span class="dv">1</span>, <span class="fu">pure</span> <span class="dt">TyBool</span>)</span>
<span id="cb30-8"><a href="#cb30-8"></a>      ] <span class="op">&lt;&gt;</span></span>
<span id="cb30-9"><a href="#cb30-9"></a>      [ (<span class="dv">5</span>, <span class="dt">TyFun</span> <span class="op">&lt;$&gt;</span> arbType (n <span class="ot">`div`</span> <span class="dv">2</span>) <span class="op">&lt;*&gt;</span> arbType (n <span class="ot">`div`</span> <span class="dv">2</span>))</span>
<span id="cb30-10"><a href="#cb30-10"></a>      <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb30-11"><a href="#cb30-11"></a>      ]</span>
<span id="cb30-12"><a href="#cb30-12"></a>    arbVar <span class="ot">=</span> elements [[c] <span class="op">|</span> c <span class="ot">&lt;-</span> [<span class="ch">'A'</span><span class="op">..</span><span class="ch">'Z'</span>]]</span>
<span id="cb30-13"><a href="#cb30-13"></a></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Constraint</span> <span class="kw">where</span></span>
<span id="cb30-15"><a href="#cb30-15"></a>  arbitrary <span class="ot">=</span> (<span class="op">:~:</span>) <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</span></code></pre></div>
<p>Then we write the function <code>unifies</code>, which checks whether a substitution unifies the constraints. (Remember: a substitution <span class="math inline">\(\mathcal{S}\)</span> satisfies a list of constraints <span class="math inline">\(C\)</span> if for all constraints <span class="math inline">\(\tau \sim \tau'\)</span> in <span class="math inline">\(C\)</span>, <span class="math inline">\(\mathcal{S}\tau = \mathcal{S}\tau'\)</span>.)</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="ot">unifies ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> [<span class="dt">Constraint</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>unifies s cs <span class="ot">=</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>  <span class="kw">let</span> cs' <span class="ot">=</span> <span class="fu">fmap</span> (substConstraint s) cs</span>
<span id="cb31-4"><a href="#cb31-4"></a>   <span class="kw">in</span> <span class="fu">all</span> (\(t1 <span class="op">:~:</span> t2) <span class="ot">-&gt;</span> t1 <span class="op">==</span> t2) cs'</span></code></pre></div>
<p>Now we can write our property, which will check whether every successful <code>solve</code> returns a substitution that unifies the list of constraints. We will discard errors of <code>solve</code>, since they occur quite often for arbitrary constraints, but aren’t useful for checking the property.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">prop_solveUnifies ::</span> [<span class="dt">Constraint</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>prop_solveUnifies cs <span class="ot">=</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>  <span class="kw">case</span> solve cs <span class="kw">of</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    <span class="co">-- Discard errors</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>    <span class="dt">Left</span> _      <span class="ot">-&gt;</span> property <span class="dt">Discard</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>    <span class="dt">Right</span> subst <span class="ot">-&gt;</span> property <span class="op">$</span> unifies subst cs</span></code></pre></div>
<p>Now we can check the property:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a>ghci<span class="op">&gt;</span> quickCheck prop_solveUnifies</span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests; <span class="dv">637</span> discarded<span class="op">.</span></span></code></pre></div>
Looks good!
</details>
<h3 id="typing-rules">Typing rules</h3>
<p>Now we know how to solve constraints, but we don’t know how to actually generate them. The typing rules will generate the constraints that should be solves afterwards.</p>
<p>Let’s first look at some easy rules. The rules for the values of the simple types are the still the same as for the simply typed lambda calculus, with the addition of <span class="math inline">\(\ldots \mid \varnothing\)</span> at the end of the judgement, which states that the rules don’t generate any constraints (an empty set):</p>
<p>The rule for applications is also not that hard:</p>
<p><span class="math display">\[
  \text{T-App: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      X \text{ fresh} \\
      C' = C_1 \cup C_2 \cup \{\tau_1 \sim \tau_2 \rightarrow X\}
    \end{array}
  }{
    \Gamma \vdash t_1\ t_2 : X \mid C'
  }
\]</span></p>
<p>When type checking the application <span class="math inline">\(t_1\ t_2\)</span>, we first type check <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span>. We then generate a new constraint set which consists of all the constraints of <span class="math inline">\(C_1\)</span>, all of <span class="math inline">\(C_2\)</span> and the constraint <span class="math inline">\(\tau_1 \sim \tau_2 \rightarrow X\)</span>. (The <span class="math inline">\(\cup\)</span> symbol is mathematical notation for the <a href="https://en.wikipedia.org/wiki/Union_%28set_theory%29"><em>union</em></a> of two sets.) Because <span class="math inline">\(t_1\)</span> is applied to <span class="math inline">\(t_2\)</span>, <span class="math inline">\(t_1\)</span> should be a function with a parameter of the type of <span class="math inline">\(t_2\)</span>. We can’t yet know the resulting type, so we use a fresh type variable, denoted by <span class="math inline">\(X\)</span>, for which we add the constraint that <span class="math inline">\(\tau_1\)</span> should be equal to <span class="math inline">\(\tau_2 \rightarrow X\)</span>.</p>
<p>To state that <span class="math inline">\(X\)</span> should be a freshly chosen type variable, we write <span class="math inline">\(X \text{ fresh}\)</span> in the typing rule. A fresh type variable is a type variable which is not already used elsewhere. Because all terms are implicitly typed (that is, they don’t contain types in their syntax), we can confidently use a predefined list of fresh type variables, since there is no chance of them clashing with type variables written by the programmer (because they don’t exist).</p>
<p>Other rules might add constraints regarding <span class="math inline">\(X\)</span>. The type inference of <span class="math inline">\(t_1\ t_2 + 3\)</span>, for example, will add the constraint <span class="math inline">\(X \sim \mathsf{Int}\)</span>.</p>
<p>The typing rules for if-then-else terms and addition terms are very easy: they are almost the same as for the simply typed lambda calculus, but now we can use constraints to specify that the condition of an if-then-else term must be a boolean, etc.:</p>
<p><span class="math display">\[
  \text{T-If: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      \Gamma \vdash t_3 : \tau_3 \mid C_3 \\
      C' = C_1 \cup C_2 \cup C_3 \cup \{\tau_1 \sim \mathsf{Bool}, \tau_2 \sim \tau_3\}
    \end{array}
  }{
    \Gamma \vdash \mathbf{if}\ t_1\ \mathbf{then}\ t_2\ \mathbf{else}\ t_3 : \tau_2 \mid C'
  }
\]</span></p>
<p><span class="math display">\[
  \text{T-Add: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      C' = C_1 \cup C_2 \cup \{\tau_1 \sim \mathsf{Int}, \tau_2 \sim \mathsf{Int}\}
    \end{array}
  }{
    \Gamma \vdash t_1 + t_2 : \mathsf{Int} \mid C'
  }
\]</span></p>
<p>The rule for variables is a bit more involved. It looks like this:</p>
<p><span class="math display">\[
  \text{T-Var: } \frac{
    \begin{array}{c}
      x : \sigma \in \Gamma \\
      \tau = \mathit{inst}(\sigma)
    \end{array}
  }{
    \Gamma \vdash x : \tau \mid \varnothing
  }
\]</span></p>
<p>Remember that the context <span class="math inline">\(\Gamma\)</span> contains polytypes, but our typing relation uses monotypes (<span class="math inline">\(\Gamma \vdash t : \tau\)</span> instead of <span class="math inline">\(\Gamma \vdash t : \sigma\)</span>). To fix this, we use a function called <span class="math inline">\(\mathit{inst}\)</span> (short for ‘instantiate’), which takes as its parameter a polytype <span class="math inline">\(\forall \vec{X}. \tau\)</span>. For every type variable <span class="math inline">\(X_i\)</span> in <span class="math inline">\(\vec{X}\)</span> (which is a list of type variables), it generates a new, fresh type variable <span class="math inline">\(Y_i\)</span>. It then performs the substitution <span class="math inline">\([X_1 := Y_1, \ldots, X_n := Y_n]\)</span> on <span class="math inline">\(\tau\)</span> and returns the result.</p>
<p>This trick is necessary for <em>let-polymorphism</em> (which I’ll discuss in more detail for the typing rule for let-in terms). When inferring the type of the term <span class="math display">\[
\begin{array}{l}
  \mathbf{let}\ \mathsf{id} = \lambda x. x\ \mathbf{in} \\
  \mathbf{if}\ \mathsf{id}\ \mathsf{True}\ \mathbf{then}\ \mathsf{id}\ 4\ \mathbf{else}\ 5
\end{array}
\]</span> we would add <span class="math inline">\(\mathsf{id} : \forall A. A \rightarrow A\)</span> to the context. When we come across the term <span class="math inline">\(\mathsf{id}\ \mathsf{True}\)</span>, we would (without using <span class="math inline">\(\mathit{inst}\)</span>) add the constraint <span class="math inline">\(A \sim \mathsf{Bool}\)</span>. But later, when we type check <span class="math inline">\(\mathsf{if}\ 4\)</span>, we would also add the constraint <span class="math inline">\(A \sim \mathsf{Int}\)</span>. This results in an error, since the unification algorithm can’t unify <span class="math inline">\(\mathsf{Bool} \sim \mathsf{Int}\)</span> (and rightly so). <span class="math inline">\(\mathit{inst}\)</span> prevents this problem, as we’ll see when looking at T-Let.</p>
<p>The rule for lambda abstractions looks like this:</p>
<p><span class="math display">\[
  \text{T-Abs: } \frac{
    \begin{array}{c}
      X \text{ fresh} \\
      \Gamma, x : \forall \varnothing. X \vdash t : \tau \mid C
    \end{array}
  }{
    \Gamma \vdash \lambda x. t : X \rightarrow \tau \mid C
  }
\]</span></p>
<p>This can be read as follows: <em>if <span class="math inline">\(X\)</span> is a free type variable and <span class="math inline">\(\Gamma, x : \forall \varnothing. X\)</span> entails that <span class="math inline">\(t\)</span> has type <span class="math inline">\(\tau\)</span> with the generated constraints <span class="math inline">\(C\)</span>, then <span class="math inline">\(\Gamma\)</span> entails that <span class="math inline">\(\lambda x. t\)</span> has type <span class="math inline">\(X \rightarrow \tau\)</span> with the same generated constraint set <span class="math inline">\(C\)</span>.</em> Since the constraint set stays the same, the T-Abs rule does not introduce any constraints.</p>
<p>Because lambda abstractions are no longer annotated with the type of the parameter (<span class="math inline">\(\lambda x : \tau. t\)</span>), we don’t know what type we should give <span class="math inline">\(x\)</span> in the context to type check the body of the lambda abstraction (<span class="math inline">\(t\)</span>). We therefore use a fresh type variable <span class="math inline">\(X\)</span> as <span class="math inline">\(x\)</span>’s type. But, since the context contains polytypes, we can’t just add the pair <span class="math inline">\(x : X\)</span>. We instead add the pair <span class="math inline">\(x : \forall \varnothing. X\)</span>.</p>
<p>Not binding <span class="math inline">\(X\)</span> with a <span class="math inline">\(\forall\)</span> (i.e., adding <span class="math inline">\(x : \forall X. X\)</span>) prevents <span class="math inline">\(\mathit{inst}\)</span> from applying let-polymorphism to the arguments of lambda abstractions. The above example using a let-in term would not work as a lambda abstraction: <span class="math inline">\((\lambda \mathsf{id}. \mathbf{if}\ \mathsf{id}\ \mathsf{True}\ \mathbf{then}\ \mathsf{id}\ 4\ \mathbf{else}\ 5)\ (\lambda x. x)\)</span> would fail to type check.</p>
<p>The rule for let-in terms, finally, looks like this:</p>
<p><span class="math display">\[
  \text{T-Let: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \mathcal{S} = \mathit{solve}(C_1) \\
      \sigma = \mathit{gen}(\mathcal{S}\Gamma, \mathcal{S}\tau_1) \\
      \Gamma, x : \sigma \vdash t_2 : \tau_2 \mid C_2
    \end{array}
  }{
    \Gamma \vdash \mathbf{let}\ x = t_1\ \mathbf{in}\ t_2 : \tau_2 \mid C_2
  }
\]</span></p>
<p>This rule is executed in the following steps:</p>
<ol type="1">
<li>The type of <span class="math inline">\(t_1\)</span> is determined.</li>
<li>The constraints generated while inferring the type of <span class="math inline">\(t_1\)</span> are solved using the <code>solve</code> function, giving us the substitution <span class="math inline">\(\mathcal{S}\)</span>.</li>
<li>The substitution is applied to the context <span class="math inline">\(\Gamma\)</span> and <span class="math inline">\(\tau_1\)</span> and the resulting type is <em>generalised</em> (using the <span class="math inline">\(\mathit{gen}\)</span> function). The <span class="math inline">\(\mathit{gen}\)</span> function creates a polytype <span class="math inline">\(\sigma\)</span> of the form <span class="math inline">\(\forall \vec{X}. \mathcal{S}\tau_1\)</span> for the monotype <span class="math inline">\(\mathcal{S}\tau_1\)</span> in which all free type variables <span class="math inline">\(\vec{X}\)</span> of <span class="math inline">\(\mathcal{S}\tau_1\)</span> (not occurring in <span class="math inline">\(\mathcal{S}\Gamma\)</span>) are bound by a <span class="math inline">\(\forall\)</span>.</li>
<li>The type of <span class="math inline">\(t_2\)</span> is determined with <span class="math inline">\(x : \sigma\)</span> added to the context.</li>
</ol>
<p>This rule adds <em>let-polymorphism</em> to the language. These quite complicated steps are necessary to actually make use of polymorphism. As we saw before, we want lambda abstractions to not support polymorphism, so a parameter can only be used on one concrete type. But for let-in terms, we do want to be able to use the bound variable on multiple concrete types: the identity function on booleans, integers, integer-to-boolean functions, etc.</p>
<p>In the rule for variables, T-Var, we introduced the <span class="math inline">\(\mathit{inst}\)</span> function. It creates a fresh type variable for every type variable bound in a polytype. To prevent it from generalising the parameters of lambda abstractions, we didn’t bind any type variables in the polytype we added to the context: <span class="math inline">\(\forall \varnothing. X\)</span>. For let-in terms, however, we do want <span class="math inline">\(\mathit{inst}\)</span> to create another instance for the bound variable for every occurrence. Therefore, we find the most general type for the variable, and add it to the context. When type checking the term <span class="math inline">\(\mathbf{let}\ \mathsf{id} = \lambda x. x\ \mathbf{in}\ \mathsf{id}\ 1\)</span>, for example, <span class="math inline">\(\mathsf{id}\)</span> is added to the context with its most general type: <span class="math inline">\(\forall X. X \rightarrow X\)</span>. When typing the body of the let-in term, then, the type of <span class="math inline">\(\mathsf{id}\)</span> is instantiated as <span class="math inline">\(Y \rightarrow Y\)</span> for example. Then the constraint <span class="math inline">\(Y \sim \mathsf{Int}\)</span> is generated, because <span class="math inline">\(\mathsf{id}\)</span> is applied to <span class="math inline">\(1\)</span>, but <span class="math inline">\(X\)</span> is still untouched.</p>
<p>With these typing rules, we can move on to implementing the type inference algorithm.</p>
<h3 id="implementation">Implementation</h3>
<p>For the implementation, we will use so-called <a href="https://hackage.haskell.org/package/mtl">monad transformers</a>. However, you should not need to understand how monad transformers work in order to understand the implementation.</p>
<p>Our inference monad looks like this:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">type</span> <span class="dt">Infer</span> a <span class="ot">=</span> <span class="dt">RWST</span> <span class="dt">Context</span> [<span class="dt">Constraint</span>] [<span class="dt">String</span>] (<span class="dt">Except</span> <span class="dt">TypeError</span>) a</span>
<span id="cb34-2"><a href="#cb34-2"></a></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="kw">type</span> <span class="dt">Context</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Polytype</span></span></code></pre></div>
<details>
<p><summary>The definition of <code>TypeError</code></summary></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">data</span> <span class="dt">TypeError</span></span></code></pre></div>
<p>The variable was not bound by a lambda abstraction.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a>  <span class="ot">=</span> <span class="dt">UnboundVariable</span> <span class="dt">String</span></span></code></pre></div>
<p>An error occurred during unification.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a>  <span class="op">|</span> <span class="dt">UnifyError</span> <span class="dt">UnifyError</span></span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</details>
<p>The inference monad is a <code>Reader</code> monad for the <code>Context</code>, which is practically the same as having a <code>Context</code> parameter for every function inside the <code>Infer</code> monad, which is what we did before. Everywhere inside the <code>Infer</code> monad we can get the context, but we can’t change it. <code>Infer</code> is also a <code>Writer</code> for a list of <code>Constraint</code>s, which means that we can write to a list of constraints. This list of constraints is the <span class="math inline">\(\ldots \mid C\)</span> in the typing rules. <code>Infer</code> is furthermore a <code>State</code> for a list of <code>String</code>s, which will be the supply of fresh type variables. And lastly, <code>Infer</code> can throw <code>TypeError</code>s.</p>
<p>Using <code>runInfer</code>, we can convert a value of <code>Infer a</code> to an <code>Either TypeError (a, [String], [Constraint])</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="ot">runInfer ::</span> <span class="dt">Context</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>         <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb39-3"><a href="#cb39-3"></a>         <span class="ot">-&gt;</span> <span class="dt">Infer</span> a</span>
<span id="cb39-4"><a href="#cb39-4"></a>         <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeError</span> (a, [<span class="dt">String</span>], [<span class="dt">Constraint</span>])</span>
<span id="cb39-5"><a href="#cb39-5"></a>runInfer ctx fs m <span class="ot">=</span> runExcept <span class="op">$</span> runRWST m ctx fs</span></code></pre></div>
<p>First, we need a function that generates a fresh type variable. The state should be an infinite list of type variable names, so we should always be able to get the following element from the list:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="ot">fresh ::</span> <span class="dt">Infer</span> <span class="dt">String</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>fresh <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>  freshVars <span class="ot">&lt;-</span> get</span>
<span id="cb40-4"><a href="#cb40-4"></a>  <span class="kw">case</span> freshVars <span class="kw">of</span></span>
<span id="cb40-5"><a href="#cb40-5"></a>    []     <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Non-infinite list of fresh type variables.&quot;</span></span>
<span id="cb40-6"><a href="#cb40-6"></a>    (f<span class="op">:</span>fs) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>      put fs</span>
<span id="cb40-8"><a href="#cb40-8"></a>      <span class="fu">pure</span> f</span></code></pre></div>
<p>With <code>get :: Infer [String]</code> we can get the list of type variables. When it’s empty, we just use <code>error</code> since the programmer has made a mistake by not using an infinite list of fresh type variables. When the list is non-empty, we return the <code>head</code>, and we use the <code>tail</code> as the new state by using <code>put :: [String] -&gt; Infer ()</code>, which replaces the state.</p>
<p>For the initial state of fresh variables, we will use the following:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="ot">freshVariables ::</span> [<span class="dt">String</span>]</span>
<span id="cb41-2"><a href="#cb41-2"></a>freshVariables <span class="ot">=</span> <span class="fu">concatMap</span> (\n <span class="ot">-&gt;</span> [l <span class="op">:</span> n <span class="op">|</span> l <span class="ot">&lt;-</span> [<span class="ch">'A'</span><span class="op">..</span><span class="ch">'Z'</span>]]) <span class="op">$</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>  <span class="st">&quot;&quot;</span> <span class="op">:</span> <span class="fu">fmap</span> <span class="fu">show</span> [<span class="dv">1</span><span class="op">..</span>]</span></code></pre></div>
<p>This list will look something like:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a>[<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="op">...</span>, <span class="st">&quot;Z&quot;</span>, <span class="st">&quot;A1&quot;</span>, <span class="st">&quot;B1&quot;</span>, <span class="op">...</span>, <span class="st">&quot;Z1&quot;</span>, <span class="st">&quot;A2&quot;</span>, <span class="st">&quot;B2&quot;</span>, <span class="op">...</span>]</span></code></pre></div>
<p>We will also need the <code>inst</code> function:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="ot">inst ::</span> <span class="dt">Polytype</span> <span class="ot">-&gt;</span> <span class="dt">Infer</span> <span class="dt">Type</span></span>
<span id="cb43-2"><a href="#cb43-2"></a>inst (<span class="dt">TyForall</span> xs ty) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb43-3"><a href="#cb43-3"></a>  ys <span class="ot">&lt;-</span> <span class="fu">mapM</span> (<span class="fu">const</span> fresh) xs</span>
<span id="cb43-4"><a href="#cb43-4"></a>  <span class="kw">let</span> subst <span class="ot">=</span> Map.fromList <span class="op">$</span> <span class="fu">zip</span> xs (<span class="fu">fmap</span> <span class="dt">TyVar</span> ys)</span>
<span id="cb43-5"><a href="#cb43-5"></a>  <span class="fu">pure</span> <span class="op">$</span> substType subst ty</span></code></pre></div>
<p>For every type variable <span class="math inline">\(X\)</span> bound by the <span class="math inline">\(\forall\)</span>, we create a fresh type variable <span class="math inline">\(Y\)</span>. Then we apply the substitution which substitutes every <span class="math inline">\(X_i\)</span> for <span class="math inline">\(Y_i\)</span>.</p>
<p>We also need the <code>gen</code> function, but before we can write it, we need to be able to get the set of free type variables from a type:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="ot">freeVarsType ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">String</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>freeVarsType <span class="dt">TyBool</span>        <span class="ot">=</span> Set.empty</span>
<span id="cb44-3"><a href="#cb44-3"></a>freeVarsType <span class="dt">TyInt</span>         <span class="ot">=</span> Set.empty</span>
<span id="cb44-4"><a href="#cb44-4"></a>freeVarsType (<span class="dt">TyVar</span> x)     <span class="ot">=</span> Set.singleton x</span>
<span id="cb44-5"><a href="#cb44-5"></a>freeVarsType (<span class="dt">TyFun</span> t1 t2) <span class="ot">=</span> freeVarsType t1 <span class="ot">`Set.union`</span> freeVarsType t2</span></code></pre></div>
<p>And the free type variables from a polytype, which are the free type variables in the monotype that are not bound by the <span class="math inline">\(\forall\)</span>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a><span class="ot">freeVarsPolytype ::</span> <span class="dt">Polytype</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">String</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>freeVarsPolytype (<span class="dt">TyForall</span> xs ty) <span class="ot">=</span> freeVarsType ty <span class="ot">`Set.difference`</span> Set.fromList xs</span></code></pre></div>
<p>And also from the context, which corresponds to the union of the free type variables of all polytypes in the context:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a><span class="ot">freeVarsContext ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">String</span></span>
<span id="cb46-2"><a href="#cb46-2"></a>freeVarsContext <span class="ot">=</span> <span class="fu">foldMap</span> freeVarsPolytype</span></code></pre></div>
<p>Now we can write <code>gen</code>. We will write it outside the <code>Infer</code> monad, because it will be useful elsewhere too.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="ot">gen ::</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Polytype</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>gen ctx ty <span class="ot">=</span></span>
<span id="cb47-3"><a href="#cb47-3"></a>  <span class="kw">let</span> xs <span class="ot">=</span> Set.toList (freeVarsType ty <span class="ot">`Set.difference`</span> freeVarsContext ctx)</span>
<span id="cb47-4"><a href="#cb47-4"></a>   <span class="kw">in</span> <span class="dt">TyForall</span> xs ty</span></code></pre></div>
<p><code>gen</code> just finds the free type variables of <code>ty</code> which don’t occur in the context, and returns a polytype in which those type variables are bound.</p>
<p>We will also need to be able to apply a substitution to a context, by applying the substitution to every polytype in the context:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1"></a><span class="ot">substContext ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="ot">-&gt;</span> <span class="dt">Context</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>substContext s <span class="ot">=</span> <span class="fu">fmap</span> (substPolytype s)</span></code></pre></div>
<p>Now we can finally implement the type inference algorithm:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1"></a><span class="ot">infer ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Infer</span> <span class="dt">Type</span></span></code></pre></div>
<p><span class="math display">\[
  \text{T-False: } \frac{
  }{
    \varnothing \vdash \mathsf{True} : \mathsf{Bool} \mid \varnothing
  }
\]</span></p>
<p><span class="math display">\[
  \text{T-True: } \frac{
  }{
    \varnothing \vdash \mathsf{True} : \mathsf{Bool} \mid \varnothing
  }
\]</span></p>
<p><span class="math display">\[
  \text{T-Int: } \frac{
  }{
    \varnothing \vdash n : \mathsf{Int} \mid \varnothing
  }
\]</span></p>
<p>Values of the simple types are, of course, easy:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a>infer <span class="dt">TmFalse</span>   <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">TyBool</span></span>
<span id="cb50-2"><a href="#cb50-2"></a>infer <span class="dt">TmTrue</span>    <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">TyBool</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>infer (<span class="dt">TmInt</span> _) <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">TyInt</span></span></code></pre></div>
<p><span class="math display">\[
  \text{T-App: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      X \text{ fresh} \\
      C' = C_1 \cup C_2 \cup \{\tau_1 \sim \tau_2 \rightarrow X\}
    \end{array}
  }{
    \Gamma \vdash t_1\ t_2 : X \mid C'
  }
\]</span></p>
<p>For applications:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a>infer (<span class="dt">TmApp</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We first infer the types of <code>t1</code> and <code>t2</code>:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a>  ty1 <span class="ot">&lt;-</span> infer t1</span>
<span id="cb52-2"><a href="#cb52-2"></a>  ty2 <span class="ot">&lt;-</span> infer t2</span></code></pre></div>
<p>We generate a fresh type variable <code>f</code>:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a>  f <span class="ot">&lt;-</span> <span class="dt">TyVar</span> <span class="op">&lt;$&gt;</span> fresh</span></code></pre></div>
<p>We generate the constraint <code>ty1 :~: TyFun ty2 f</code>. We can add it to the list of constraints using the <code>tell :: [Constraint] -&gt; Infer ()</code> function.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a>  tell [ty1 <span class="op">:~:</span> <span class="dt">TyFun</span> ty2 f]</span></code></pre></div>
<p>Finally, we return the fresh type variable as the type:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a>  <span class="fu">pure</span> f</span></code></pre></div>
<p><span class="math display">\[
  \text{T-If: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      \Gamma \vdash t_3 : \tau_3 \mid C_3 \\
      C' = C_1 \cup C_2 \cup C_3 \cup \{\tau_1 \sim \mathsf{Bool}, \tau_2 \sim \tau_3\}
    \end{array}
  }{
    \Gamma \vdash \mathbf{if}\ t_1\ \mathbf{then}\ t_2\ \mathbf{else}\ t_3 : \tau_2 \mid C'
  }
\]</span></p>
<p>For if-then-else terms, we generate the constraints that the condition should be a boolean and that the arms should be of the same type :</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a>infer (<span class="dt">TmIf</span> t1 t2 t3) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>  ty1 <span class="ot">&lt;-</span> infer t1</span>
<span id="cb56-3"><a href="#cb56-3"></a>  ty2 <span class="ot">&lt;-</span> infer t2</span>
<span id="cb56-4"><a href="#cb56-4"></a>  ty3 <span class="ot">&lt;-</span> infer t3</span>
<span id="cb56-5"><a href="#cb56-5"></a>  tell [ty1 <span class="op">:~:</span> <span class="dt">TyBool</span>, ty2 <span class="op">:~:</span> ty3]</span>
<span id="cb56-6"><a href="#cb56-6"></a>  <span class="fu">pure</span> ty2</span></code></pre></div>
<p><span class="math display">\[
  \text{T-Add: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \Gamma \vdash t_2 : \tau_2 \mid C_2 \\
      C' = C_1 \cup C_2 \cup \{\tau_1 \sim \mathsf{Int}, \tau_2 \sim \mathsf{Int}\}
    \end{array}
  }{
    \Gamma \vdash t_1 + t_2 : \mathsf{Int} \mid C'
  }
\]</span></p>
<p>The operands of an addition should be integers, and the result is also an integer:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1"></a>infer (<span class="dt">TmAdd</span> t1 t2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>  ty1 <span class="ot">&lt;-</span> infer t1</span>
<span id="cb57-3"><a href="#cb57-3"></a>  ty2 <span class="ot">&lt;-</span> infer t2</span>
<span id="cb57-4"><a href="#cb57-4"></a>  tell [ty1 <span class="op">:~:</span> <span class="dt">TyInt</span>, ty2 <span class="op">:~:</span> <span class="dt">TyInt</span>]</span>
<span id="cb57-5"><a href="#cb57-5"></a>  <span class="fu">pure</span> <span class="dt">TyInt</span></span></code></pre></div>
<p><span class="math display">\[
  \text{T-Var: } \frac{
    \begin{array}{c}
      x : \sigma \in \Gamma \\
      \tau = \mathit{inst}(\sigma)
    \end{array}
  }{
    \Gamma \vdash x : \tau \mid \varnothing
  }
\]</span></p>
<p>For variables, we use the <code>inst</code> function:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1"></a>infer (<span class="dt">TmVar</span> x) <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We can get the context using <code>ask</code>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1"></a>  ctx <span class="ot">&lt;-</span> ask</span></code></pre></div>
<p>We look up <code>x</code>:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1"></a>  <span class="kw">case</span> Map.lookup x ctx <span class="kw">of</span></span></code></pre></div>
<p>When it doesn’t exist in the context, we use <code>throwError :: TypeError -&gt; Infer ()</code> to throw an error:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> throwError <span class="op">$</span> <span class="dt">UnboundVariable</span> x</span></code></pre></div>
<p>Otherwise, we use <code>inst</code> on the type:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1"></a>    <span class="dt">Just</span> ty <span class="ot">-&gt;</span> inst ty</span></code></pre></div>
<p><span class="math display">\[
  \text{T-Abs: } \frac{
    \begin{array}{c}
      X \text{ fresh} \\
      \Gamma, x : \forall \varnothing. X \vdash t : \tau \mid C
    \end{array}
  }{
    \Gamma \vdash \lambda x. t : X \rightarrow \tau \mid C
  }
\]</span></p>
<p>Then lambda abstractions. Using <code>local :: (Context -&gt; Context) -&gt; Infer a -&gt; Infer a</code> we can update the context for a local sub-computation. To infer the type of <code>t</code>, we need to add <code>x</code>’s type to the context, so we use <code>local</code>. Note that the context is not changed in the outer computation:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1"></a>infer (<span class="dt">TmAbs</span> x t) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>  f <span class="ot">&lt;-</span> <span class="dt">TyVar</span> <span class="op">&lt;$&gt;</span> fresh </span>
<span id="cb63-3"><a href="#cb63-3"></a>  ty <span class="ot">&lt;-</span> local (Map.insert x (<span class="dt">TyForall</span> [] f)) <span class="op">$</span> infer t</span>
<span id="cb63-4"><a href="#cb63-4"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">TyFun</span> f ty</span></code></pre></div>
<p><span class="math display">\[
  \text{T-Let: } \frac{
    \begin{array}{c}
      \Gamma \vdash t_1 : \tau_1 \mid C_1 \\
      \mathcal{S} = \mathit{solve}(C_1) \\
      \sigma = \mathit{gen}(\mathcal{S}\Gamma, \mathcal{S}\tau_1) \\
      \Gamma, x : \sigma \vdash t_2 : \tau_2 \mid C_2
    \end{array}
  }{
    \Gamma \vdash \mathbf{let}\ x = t_1\ \mathbf{in}\ t_2 : \tau_2 \mid C_2
  }
\]</span></p>
<p>And, finally, let-in terms:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1"></a>infer (<span class="dt">TmLet</span> x t1 t2) <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>We first get the context:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1"></a>  ctx <span class="ot">&lt;-</span> ask</span></code></pre></div>
<p>Then we use <code>listen :: Infer a -&gt; Infer (a, [Constraint])</code> to ‘listen’ to the constraints generated by <code>infer t1</code>. These constraints will not be added to the final list of constraints, but are only generated ‘locally’:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1"></a>  (ty1, cs) <span class="ot">&lt;-</span> listen <span class="op">$</span> infer t1</span></code></pre></div>
<p>Now we try to solve the constraints. If they’re not solvable, we just throw an error. Otherwise, we obtain a substitution:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1"></a>  subst <span class="ot">&lt;-</span> <span class="kw">case</span> solve cs <span class="kw">of</span></span>
<span id="cb67-2"><a href="#cb67-2"></a>    <span class="dt">Left</span> e  <span class="ot">-&gt;</span> throwError <span class="op">$</span> <span class="dt">UnifyError</span> e</span>
<span id="cb67-3"><a href="#cb67-3"></a>    <span class="dt">Right</span> s <span class="ot">-&gt;</span> <span class="fu">pure</span> s</span></code></pre></div>
<p>We apply the substitution to <code>t1</code>’s type, <code>ty1</code>, giving us <code>ty1'</code>.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1"></a>  <span class="kw">let</span> ty1' <span class="ot">=</span> substType subst ty1</span></code></pre></div>
<p>And we generalise <code>ty1'</code> in the context to which we have also applied the substitution, giving us a polytype <code>s</code>:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1"></a>  <span class="kw">let</span> s <span class="ot">=</span> gen (substContext subst ctx) ty1'</span></code></pre></div>
<p>We add <code>s</code> to the context and infer <code>t2</code>’s type:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1"></a>  local (Map.insert x s) <span class="op">$</span> infer t2</span></code></pre></div>
<p>That’s it! We’ve written an function which runs the inference algorithm on a term, giving us a type and a list of constraints.</p>
<p>Now, we still need to solve the constraints and apply the substitution to the type. We will write the function <code>polytypeOf</code>, which runs the inference algorithm, solves the constraints, applies the substitution, and turns the resulting type into a polytype:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1"></a><span class="ot">polytypeOf ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeError</span> <span class="dt">Polytype</span></span>
<span id="cb71-2"><a href="#cb71-2"></a>polytypeOf t <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>Run the inference algorithm in an empty context<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, giving us a type <code>ty</code>, a list of fresh variables <code>fs</code> and a list of constraints <code>cs</code>:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1"></a>  (ty, fs, cs) <span class="ot">&lt;-</span> runInfer Map.empty freshVariables <span class="op">$</span> infer t</span></code></pre></div>
<p>Solve the constraints to obtain a substitution. Because <code>solve</code> returns an <code>Either UnifyError Subst</code>, we need to turn its error into a <code>TypeError</code>, which we can do by applying the type constructor <code>TypeError</code> to it. To do this, we use <code>first :: Bifunctor p =&gt; (a -&gt; b) -&gt; p a c -&gt; p b c</code>:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1"></a>  subst <span class="ot">&lt;-</span> first <span class="dt">UnifyError</span> <span class="op">$</span> solve cs</span></code></pre></div>
<p>We apply the substitution to <code>ty</code>:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1"></a>  <span class="kw">let</span> ty' <span class="ot">=</span> substType subst ty</span></code></pre></div>
<p>We generalise the type in an empty context, giving us the polytype <code>s</code>:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1"></a>  <span class="kw">let</span> s <span class="ot">=</span> gen Map.empty ty'</span></code></pre></div>
<p>And we return <code>s</code>:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1"></a>  <span class="dt">Right</span> s</span></code></pre></div>
<p>Let’s try it!</p>
<p>The type of <code>id</code>:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1"></a>polytypeOf tmId</span>
<span id="cb77-2"><a href="#cb77-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> [<span class="st">&quot;A&quot;</span>] (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>)))</span></code></pre></div>
<p>That is <span class="math inline">\(\forall A. A \rightarrow A\)</span>, correct!</p>
<p>The type of <code>const</code>:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1"></a>polytypeOf tmConst</span>
<span id="cb78-2"><a href="#cb78-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> [<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>] (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>) (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;B&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;A&quot;</span>))))</span></code></pre></div>
<p><span class="math inline">\(\forall A\ B. A \rightarrow B \rightarrow A\)</span>, again correct!</p>
<p>Now let’s try to use let-polymorphism, by trying the term: <span class="math display">\[
\begin{array}{l}
  \mathbf{let}\ \mathsf{id} = \lambda x. x\ \mathbf{in} \\
  \mathbf{if}\ \mathsf{id}\ \mathsf{True}\ \mathbf{then}\ \mathsf{id}\ 4\ \mathbf{else}\ 5
\end{array}
\]</span></p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1"></a>polytypeOf (<span class="dt">TmLet</span> <span class="st">&quot;id&quot;</span> (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">TmIf</span> (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) <span class="dt">TmTrue</span>) (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) (<span class="dt">TmInt</span> <span class="dv">4</span>)) (<span class="dt">TmInt</span> <span class="dv">5</span>)))</span>
<span id="cb79-2"><a href="#cb79-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> [] <span class="dt">TyInt</span>)</span></code></pre></div>
<p>And the same term, but using a lambda abstraction:</p>
<p><span class="math display">\[
  (\lambda \mathsf{id}. \mathbf{if}\ \mathsf{id}\ \mathsf{True}\ \mathbf{then}\ \mathsf{id}\ 4\ \mathbf{else}\ 5)\ (\lambda x. x)
\]</span></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1"></a>polytypeOf (<span class="dt">TmApp</span> (<span class="dt">TmAbs</span> <span class="st">&quot;id&quot;</span> (<span class="dt">TmIf</span> (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) <span class="dt">TmTrue</span>) (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>) (<span class="dt">TmInt</span> <span class="dv">4</span>)) (<span class="dt">TmInt</span> <span class="dv">5</span>))) (<span class="dt">TmAbs</span> <span class="st">&quot;x&quot;</span> (<span class="dt">TmVar</span> <span class="st">&quot;x&quot;</span>)))</span>
<span id="cb80-2"><a href="#cb80-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Left</span> (<span class="dt">UnifyError</span> (<span class="dt">CannotUnify</span> <span class="dt">TyBool</span> <span class="dt">TyInt</span>))</span></code></pre></div>
<p>Just like we expected, it can’t unify <span class="math inline">\(\mathsf{Bool} \sim \mathsf{Int}\)</span>.</p>
<p>One more: <span class="math display">\[
\begin{array}{l}
  \mathbf{let}\ \mathsf{id} = \lambda x. x\ \mathbf{in} \\
  \mathbf{let}\ \mathsf{const} = \lambda a. \lambda b. a\ \mathbf{in} \\
  \mathsf{const}\ \mathsf{id}\ \mathsf{const}
\end{array}
\]</span></p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1"></a>polytypeOf <span class="op">$</span> <span class="dt">TmLet</span> <span class="st">&quot;id&quot;</span> tmId <span class="op">$</span> <span class="dt">TmLet</span> <span class="st">&quot;const&quot;</span> tmConst <span class="op">$</span> <span class="dt">TmApp</span> (<span class="dt">TmApp</span> (<span class="dt">TmVar</span> <span class="st">&quot;const&quot;</span>) (<span class="dt">TmVar</span> <span class="st">&quot;id&quot;</span>)) (<span class="dt">TmVar</span> <span class="st">&quot;const&quot;</span>)</span>
<span id="cb81-2"><a href="#cb81-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Right</span> (<span class="dt">TyForall</span> [<span class="st">&quot;F&quot;</span>] (<span class="dt">TyFun</span> (<span class="dt">TyVar</span> <span class="st">&quot;F&quot;</span>) (<span class="dt">TyVar</span> <span class="st">&quot;F&quot;</span>)))</span></code></pre></div>
<p>It returns <span class="math inline">\(\forall F. F \rightarrow F\)</span>, which is exactly the type of <span class="math inline">\(\mathsf{id}\)</span>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We’ve explored Hindley-Milner type inference, and implemented a type inference algorithm! This language is already quite close to Haskell.</p>
<p>Some exercises you might like to do:</p>
<ol type="1">
<li>Write a function <code>simplPolytype</code> which ‘simplifies’ a polytype. It should rename the bound variables in a polytype to names in the beginning of the alphabet (or: the beginning of <code>freshVariables</code>). The polytype of the last example is <span class="math inline">\(\forall F. F \rightarrow F\)</span>, for example, but it would be nicer if <code>polytypeOf</code> returned <span class="math inline">\(\forall A. A \rightarrow A\)</span>.</li>
<li>Extend the language using other simple types and operations for them.</li>
</ol>
<p>And, if you have trouble understanding some parts, try to experiment with them a lot. And feel free to ask questions on <a href="https://www.reddit.com/r/haskell/comments/h8tpfj/type_inference_introduction_to_type_systems">Reddit</a>.</p>
<h3 id="further-reading">Further reading</h3>
<p>Other resources you might find useful:</p>
<ul>
<li><a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>, Benjamin C. Pierce, Chapters 22 and 23.</li>
<li><a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"><em>Hindley-Milner type system</em></a> on Wikipedia.</li>
<li><a href="http://dev.stephendiehl.com/fun/006_hindley_milner.html"><em>Hindley-Milner inference</em></a>, chapter 6 of Stephen Diehl’s <em>Write You a Haskell</em>.</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Pierce uses the typing relation <span class="math inline">\(\Gamma \vdash t : \tau \mid_X C\)</span>, where the set <span class="math inline">\(X\)</span> keeps track of the used type variables. This is very useful to formally reason about the type inference algorithm, but it makes the typing rules more complex than necessary for a Haskell implementation. Instead, I will just write <span class="math inline">\(X \text{ fresh}\)</span> for a type variable <span class="math inline">\(X\)</span>. This approach is more informal, since it doesn’t formally specify when a variable is <em>fresh</em>, but I think it is easier.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>If you want to extend the language by having declarations, or by making a REPL, you might want to run <code>infer</code> in a specific context, so declarations aren’t lost. You would also have to run <code>gen</code> with this context, instead of an empty context.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </section>
</article>

    </main>

    <footer>
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </body>
</html>
